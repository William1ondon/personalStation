{
  "version": 3,
  "sources": ["../../vuex-module-decorators/src/helpers.ts", "../../vuex-module-decorators/src/vuexmodule.ts", "../../vuex-module-decorators/src/module/stateFactory.ts", "../../vuex-module-decorators/src/module/staticGenerators.ts", "../../vuex-module-decorators/src/module/index.ts", "../../vuex-module-decorators/src/config.ts", "../../vuex-module-decorators/src/action.ts", "../../vuex-module-decorators/src/mutation.ts", "../../vuex-module-decorators/src/mutationaction.ts"],
  "sourcesContent": ["/**\n * Takes the properties on object from parameter source and adds them to the object\n * parameter target\n * @param {object} target  Object to have properties copied onto from y\n * @param {object} source  Object with properties to be copied to x\n */\nexport function addPropertiesToObject(target: any, source: any) {\n  for (let k of Object.keys(source || {})) {\n    Object.defineProperty(target, k, {\n      get: () => source[k]\n    })\n  }\n}\n\n/**\n * Returns a namespaced name of the module to be used as a store getter\n * @param module\n */\nexport function getModuleName(module: any): string {\n  if (!module._vmdModuleName) {\n    throw new Error(`ERR_GET_MODULE_NAME : Could not get module accessor.\n      Make sure your module has name, we can't make accessors for unnamed modules\n      i.e. @Module({ name: 'something' })`)\n  }\n  return `vuexModuleDecorators/${module._vmdModuleName}`\n}\n", "import {\n  ActionTree,\n  GetterTree,\n  Module as Mod,\n  ModuleTree,\n  MutationTree,\n  Store,\n  ActionContext\n} from 'vuex'\nimport { getModuleName } from './helpers'\n\nexport class VuexModule<S = ThisType<any>, R = any> implements Mod<S, R> {\n  /*\n   * To use with `extends Class` syntax along with decorators\n   */\n  static namespaced?: boolean\n  static state?: any | (() => any)\n  static getters?: GetterTree<any, any>\n  static actions?: ActionTree<any, any>\n  static mutations?: MutationTree<any>\n  static modules?: ModuleTree<any>\n\n  /*\n   * To use with `new VuexModule(<ModuleOptions>{})` syntax\n   */\n\n  modules?: ModuleTree<any>\n  namespaced?: boolean\n  getters?: GetterTree<S, R>\n  state?: S | (() => S)\n  mutations?: MutationTree<S>\n  actions?: ActionTree<S, R>\n  context!: ActionContext<S, R>\n\n  constructor(module: Mod<S, any>) {\n    this.actions = module.actions\n    this.mutations = module.mutations\n    this.state = module.state\n    this.getters = module.getters\n    this.namespaced = module.namespaced\n    this.modules = module.modules\n  }\n}\ntype ConstructorOf<C> = { new (...args: any[]): C }\n\nexport function getModule<M extends VuexModule>(\n  moduleClass: ConstructorOf<M>,\n  store?: Store<any>\n): M {\n  const moduleName = getModuleName(moduleClass)\n  if (store && store.getters[moduleName]) {\n    return store.getters[moduleName]\n  } else if ((moduleClass as any)._statics) {\n    return (moduleClass as any)._statics\n  }\n\n  const genStatic: (providedStore?: Store<any>) => M = (moduleClass as any)._genStatic\n  if (!genStatic) {\n    throw new Error(`ERR_GET_MODULE_NO_STATICS : Could not get module accessor.\n      Make sure your module has name, we can't make accessors for unnamed modules\n      i.e. @Module({ name: 'something' })`)\n  }\n\n  const storeModule = genStatic(store)\n\n  if (store) {\n    store.getters[moduleName] = storeModule\n  } else {\n    ;(moduleClass as any)._statics = storeModule\n  }\n\n  return storeModule\n}\n", "import { Module as Mod } from 'vuex'\n\nconst reservedKeys = ['actions', 'getters', 'mutations', 'modules', 'state', 'namespaced', 'commit']\nexport function stateFactory<S>(module: Function & Mod<S, any>) {\n  const state = new module.prototype.constructor({})\n  const s = {} as S\n  Object.keys(state).forEach((key: string) => {\n    if (reservedKeys.indexOf(key) !== -1) {\n      if (typeof state[key] !== 'undefined') {\n        throw new Error(\n          `ERR_RESERVED_STATE_KEY_USED: You cannot use the following\n        ['actions', 'getters', 'mutations', 'modules', 'state', 'namespaced', 'commit']\n        as fields in your module. These are reserved as they have special purpose in Vuex`\n        )\n      }\n      return\n    }\n    if (state.hasOwnProperty(key)) {\n      if (typeof state[key] !== 'function') {\n        ;(s as any)[key] = state[key]\n      }\n    }\n  })\n\n  return s\n}\n", "import { ActionTree, GetterTree, Module as Mod, MutationTree } from 'vuex'\nimport { DynamicModuleOptions } from '../moduleoptions'\n\nexport function staticStateGenerator<S extends Object>(\n  module: Function & Mod<S, any>,\n  modOpt: DynamicModuleOptions,\n  statics: any\n) {\n  const state: S = modOpt.stateFactory ? (module as any).state() : module.state\n  Object.keys(state).forEach((key) => {\n    if (state.hasOwnProperty(key)) {\n      // If not undefined or function means it is a state value\n      if (['undefined', 'function'].indexOf(typeof (state as any)[key]) === -1) {\n        Object.defineProperty(statics, key, {\n          get() {\n            const path = modOpt.name.split('/')\n            let data = statics.store.state\n            for (let segment of path) {\n              data = data[segment]\n            }\n            return data[key]\n          }\n        })\n      }\n    }\n  })\n}\n\nexport function staticGetterGenerator<S>(\n  module: Function & Mod<S, any>,\n  modOpt: DynamicModuleOptions,\n  statics: any\n) {\n  Object.keys(module.getters as GetterTree<S, any>).forEach((key) => {\n    if (module.namespaced) {\n      Object.defineProperty(statics, key, {\n        get() {\n          return statics.store.getters[`${modOpt.name}/${key}`]\n        }\n      })\n    } else {\n      Object.defineProperty(statics, key, {\n        get() {\n          return statics.store.getters[key]\n        }\n      })\n    }\n  })\n}\n\nexport function staticMutationGenerator<S>(\n  module: Function & Mod<S, any>,\n  modOpt: DynamicModuleOptions,\n  statics: any\n) {\n  Object.keys(module.mutations as MutationTree<S>).forEach((key) => {\n    if (module.namespaced) {\n      statics[key] = function (...args: any[]) {\n        statics.store.commit(`${modOpt.name}/${key}`, ...args)\n      }\n    } else {\n      statics[key] = function (...args: any[]) {\n        statics.store.commit(key, ...args)\n      }\n    }\n  })\n}\n\nexport function staticActionGenerators<S>(\n  module: Function & Mod<S, any>,\n  modOpt: DynamicModuleOptions,\n  statics: any\n) {\n  Object.keys(module.actions as ActionTree<S, any>).forEach((key) => {\n    if (module.namespaced) {\n      statics[key] = async function (...args: any[]) {\n        return statics.store.dispatch(`${modOpt.name}/${key}`, ...args)\n      }\n    } else {\n      statics[key] = async function (...args: any[]) {\n        return statics.store.dispatch(key, ...args)\n      }\n    }\n  })\n}\n", "import { GetterTree, Module as Mod, Store } from 'vuex'\nimport { DynamicModuleOptions, ModuleOptions } from '../moduleoptions'\nimport { stateFactory as sf } from './stateFactory'\nimport { addPropertiesToObject } from '../helpers'\nimport {\n  staticActionGenerators,\n  staticGetterGenerator,\n  staticMutationGenerator,\n  staticStateGenerator\n} from './staticGenerators'\n\nfunction registerDynamicModule<S>(module: Mod<S, any>, modOpt: DynamicModuleOptions) {\n  if (!modOpt.name) {\n    throw new Error('Name of module not provided in decorator options')\n  }\n\n  if (!modOpt.store) {\n    throw new Error('Store not provided in decorator options when using dynamic option')\n  }\n\n  modOpt.store.registerModule(\n    modOpt.name, // TODO: Handle nested modules too in future\n    module,\n    { preserveState: modOpt.preserveState || false }\n  )\n}\n\nfunction addGettersToModule<S>(\n  targetModule: Function & Mod<S, any>,\n  srcModule: Function & Mod<S, any>\n) {\n  Object.getOwnPropertyNames(srcModule.prototype).forEach((funcName: string) => {\n    const descriptor = Object.getOwnPropertyDescriptor(\n      srcModule.prototype,\n      funcName\n    ) as PropertyDescriptor\n    if (descriptor.get && targetModule.getters) {\n      targetModule.getters[funcName] = function (\n        state: S,\n        getters: GetterTree<S, any>,\n        rootState: any,\n        rootGetters: GetterTree<any, any>\n      ) {\n        const thisObj = { context: { state, getters, rootState, rootGetters } }\n        addPropertiesToObject(thisObj, state)\n        addPropertiesToObject(thisObj, getters)\n        const got = (descriptor.get as Function).call(thisObj)\n        return got\n      }\n    }\n  })\n}\n\nfunction moduleDecoratorFactory<S>(moduleOptions: ModuleOptions) {\n  return function <TFunction extends Function>(constructor: TFunction): TFunction | void {\n    const module: Function & Mod<S, any> = constructor\n    const stateFactory = () => sf(module)\n\n    if (!module.state) {\n      module.state = moduleOptions && moduleOptions.stateFactory ? stateFactory : stateFactory()\n    }\n    if (!module.getters) {\n      module.getters = {} as GetterTree<S, any>\n    }\n    if (!module.namespaced) {\n      module.namespaced = moduleOptions && moduleOptions.namespaced\n    }\n    let parentModule = Object.getPrototypeOf(module)\n    while (parentModule.name !== 'VuexModule' && parentModule.name !== '') {\n      addGettersToModule(module, parentModule)\n      parentModule = Object.getPrototypeOf(parentModule)\n    }\n    addGettersToModule(module, module)\n    const modOpt = moduleOptions as DynamicModuleOptions\n    if (modOpt.name) {\n      Object.defineProperty(constructor, '_genStatic', {\n        value: (store?: Store<any>) => {\n          let statics = { store: store || modOpt.store }\n          if (!statics.store) {\n            throw new Error(`ERR_STORE_NOT_PROVIDED: To use getModule(), either the module\n            should be decorated with store in decorator, i.e. @Module({store: store}) or\n            store should be passed when calling getModule(), i.e. getModule(MyModule, this.$store)`)\n          }\n          // ===========  For statics ==============\n          // ------ state -------\n          staticStateGenerator(module, modOpt, statics)\n\n          // ------- getters -------\n          if (module.getters) {\n            staticGetterGenerator(module, modOpt, statics)\n          }\n\n          // -------- mutations --------\n          if (module.mutations) {\n            staticMutationGenerator(module, modOpt, statics)\n          }\n          // -------- actions ---------\n          if (module.actions) {\n            staticActionGenerators(module, modOpt, statics)\n          }\n          return statics\n        }\n      })\n\n      Object.defineProperty(constructor, '_vmdModuleName', {\n        value: modOpt.name\n      })\n    }\n\n    if (modOpt.dynamic) {\n      registerDynamicModule(module, modOpt)\n    }\n    return constructor\n  }\n}\n\nexport function Module<S>(module: Function & Mod<S, any>): void\nexport function Module<S>(options: ModuleOptions): ClassDecorator\n\nexport function Module<S>(modOrOpt: ModuleOptions | (Function & Mod<S, any>)) {\n  if (typeof (modOrOpt as any) === 'function') {\n    /*\n     * @Module decorator called without options (directly on the class definition)\n     */\n    moduleDecoratorFactory({})(modOrOpt as Function & Mod<S, any>)\n  } else {\n    /*\n     * @Module({...}) decorator called with options\n     */\n    return moduleDecoratorFactory(modOrOpt)\n  }\n}\n", "export const config: IConfig = {}\n\nexport interface IConfig {\n  rawError?: boolean\n}\n", "import { Action as Act, ActionContext, Module as Mod, Payload } from 'vuex'\nimport { getModule, VuexModule } from './vuexmodule'\nimport { addPropertiesToObject, getModuleName } from './helpers'\nimport { config } from './config'\n\n/**\n * Parameters that can be passed to the @Action decorator\n */\nexport interface ActionDecoratorParams {\n  commit?: string\n  rawError?: boolean\n  root?: boolean\n}\nfunction actionDecoratorFactory<T>(params?: ActionDecoratorParams): MethodDecorator {\n  const { commit = undefined, rawError = !!config.rawError, root = false } = params || {}\n  return function (target: Object, key: string | symbol, descriptor: TypedPropertyDescriptor<any>) {\n    const module = target.constructor as Mod<T, any>\n    if (!module.hasOwnProperty('actions')) {\n      module.actions = Object.assign({}, module.actions)\n    }\n    const actionFunction: Function = descriptor.value\n    const action: Act<typeof target, any> = async function (\n      context: ActionContext<typeof target, any>,\n      payload: Payload\n    ) {\n      try {\n        let actionPayload = null\n\n        if ((module as any)._genStatic) {\n          const moduleName = getModuleName(module)\n          const moduleAccessor = context.rootGetters[moduleName]\n            ? context.rootGetters[moduleName]\n            : getModule(module as typeof VuexModule)\n          moduleAccessor.context = context\n          actionPayload = await actionFunction.call(moduleAccessor, payload)\n        } else {\n          const thisObj = { context }\n          addPropertiesToObject(thisObj, context.state)\n          addPropertiesToObject(thisObj, context.getters)\n          actionPayload = await actionFunction.call(thisObj, payload)\n        }\n        if (commit) {\n          context.commit(commit, actionPayload)\n        }\n        return actionPayload\n      } catch (e: any) {\n        throw rawError\n          ? e\n          : new Error(\n              'ERR_ACTION_ACCESS_UNDEFINED: Are you trying to access ' +\n                'this.someMutation() or this.someGetter inside an @Action? \\n' +\n                'That works only in dynamic modules. \\n' +\n                'If not dynamic use this.context.commit(\"mutationName\", payload) ' +\n                'and this.context.getters[\"getterName\"]' +\n                '\\n' +\n                new Error(`Could not perform action ${key.toString()}`).stack +\n                '\\n' +\n                e.stack\n            )\n      }\n    }\n    module.actions![key as string] = root ? { root, handler: action } : action\n  }\n}\n\nexport function Action<T, R>(\n  target: T,\n  key: string | symbol,\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => R>\n): void\nexport function Action<T>(params: ActionDecoratorParams): MethodDecorator\n\n/**\n * The @Action decorator turns an async function into an Vuex action\n *\n * @param targetOrParams the module class\n * @param key name of the action\n * @param descriptor the action function descriptor\n * @constructor\n */\nexport function Action<T, R>(\n  targetOrParams: T | ActionDecoratorParams,\n  key?: string | symbol,\n  descriptor?: TypedPropertyDescriptor<(...args: any[]) => R>\n) {\n  if (!key && !descriptor) {\n    /*\n     * This is the case when `targetOrParams` is params.\n     * i.e. when used as -\n     * <pre>\n        @Action({commit: 'incrCount'})\n        async getCountDelta() {\n          return 5\n        }\n     * </pre>\n     */\n    return actionDecoratorFactory(targetOrParams as ActionDecoratorParams)\n  } else {\n    /*\n     * This is the case when @Action is called on action function\n     * without any params\n     * <pre>\n     *   @Action\n     *   async doSomething() {\n     *    ...\n     *   }\n     * </pre>\n     */\n    actionDecoratorFactory()(targetOrParams, key!, descriptor!)\n  }\n}\n", "import { Module as Mod, Mutation as Mut, Payload } from 'vuex'\n\nexport function Mutation<T extends Object, R>(\n  target: T,\n  key: string | symbol,\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => R>\n) {\n  const module = target.constructor as Mod<T, any>\n  if (!module.hasOwnProperty('mutations')) {\n    module.mutations = Object.assign({}, module.mutations)\n  }\n  const mutationFunction: Function = descriptor.value!\n  const mutation: Mut<typeof target> = function (state: typeof target, payload: Payload) {\n    mutationFunction.call(state, payload)\n  }\n  module.mutations![key as string] = mutation\n}\n", "import { Action as Act, ActionContext, Module as Mod, Mutation as Mut, Payload, Store } from 'vuex'\nimport { addPropertiesToObject } from './helpers'\n\nexport interface MutationActionParams<M> {\n  mutate?: (keyof Partial<M>)[]\n  rawError?: boolean\n  root?: boolean\n}\n\nfunction mutationActionDecoratorFactory<T extends Object>(params: MutationActionParams<T>) {\n  return function (\n    target: T,\n    key: string | symbol,\n    descriptor: TypedPropertyDescriptor<(...args: any[]) => Promise<Partial<T> | undefined>>\n  ) {\n    const module = target.constructor as Mod<T, any>\n    if (!module.hasOwnProperty('mutations')) {\n      module.mutations = Object.assign({}, module.mutations)\n    }\n    if (!module.hasOwnProperty('actions')) {\n      module.actions = Object.assign({}, module.actions)\n    }\n    const mutactFunction = descriptor.value as (payload: any) => Promise<any>\n\n    const action: Act<typeof target, any> = async function (\n      context: ActionContext<typeof target, any>,\n      payload: Payload\n    ) {\n      try {\n        const thisObj = { context }\n        addPropertiesToObject(thisObj, context.state)\n        addPropertiesToObject(thisObj, context.getters)\n        const actionPayload = await mutactFunction.call(thisObj, payload)\n        if (actionPayload === undefined) return\n        context.commit(key as string, actionPayload)\n      } catch (e: any) {\n        if (params.rawError) {\n          throw e\n        } else {\n          console.error('Could not perform action ' + key.toString())\n          console.error(e)\n          return Promise.reject(e)\n        }\n      }\n    }\n\n    const mutation: Mut<typeof target> = function (\n      state: typeof target | Store<T>,\n      payload: Payload & { [k in keyof T]: any }\n    ) {\n      if (!params.mutate) {\n        params.mutate = Object.keys(payload) as (keyof T)[]\n      }\n      for (let stateItem of params.mutate) {\n        if (state.hasOwnProperty(stateItem) && payload.hasOwnProperty(stateItem)) {\n          ;(state as T)[stateItem] = payload[stateItem]\n        } else {\n          throw new Error(`ERR_MUTATE_PARAMS_NOT_IN_PAYLOAD\n          In @MutationAction, mutate: ['a', 'b', ...] array keys must\n          match with return type = {a: {}, b: {}, ...} and must\n          also be in state.`)\n        }\n      }\n    }\n    module.actions![key as string] = params.root ? { root: true, handler: action } : action\n    module.mutations![key as string] = mutation\n  }\n}\n\nexport function MutationAction<K, T extends K>(\n  target: { [k in keyof T]: T[k] | null },\n  key: string | symbol,\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => Promise<K>>\n): void\n\nexport function MutationAction<T>(\n  params: MutationActionParams<T>\n): (\n  target: T,\n  key: string | symbol,\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => Promise<T>>\n) => void\n\n/**\n * The @MutationAction decorator turns this into an action that further calls a mutation\n * Both the action and the mutation are generated for you\n *\n * @param paramsOrTarget the params or the target class\n * @param key the name of the function\n * @param descriptor the function body\n * @constructor\n */\nexport function MutationAction<T, K, M extends K>(\n  paramsOrTarget: MutationActionParams<T> | M,\n  key?: string | symbol,\n  descriptor?: TypedPropertyDescriptor<(...args: any[]) => Promise<Partial<K> | undefined>>\n):\n  | ((\n      target: T,\n      key: string | symbol,\n      descriptor: TypedPropertyDescriptor<(...args: any[]) => Promise<Partial<T> | undefined>>\n    ) => void)\n  | void {\n  if (!key && !descriptor) {\n    /*\n     * This is the case when `paramsOrTarget` is params.\n     * i.e. when used as -\n     * <pre>\n        @MutationAction({mutate: ['incrCount']})\n        async getCountDelta() {\n          return {incrCount: 5}\n        }\n     * </pre>\n     */\n    return mutationActionDecoratorFactory(paramsOrTarget as MutationActionParams<T>)\n  } else {\n    /*\n     * This is the case when `paramsOrTarget` is target.\n     * i.e. when used as -\n     * <pre>\n        @MutationAction\n        async getCountDelta() {\n          return {incrCount: 5}\n        }\n     * </pre>\n     */\n    mutationActionDecoratorFactory({} as MutationActionParams<K>)(\n      paramsOrTarget as K,\n      key!,\n      descriptor!\n    )\n  }\n}\n"],
  "mappings": "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",
  "names": ["stateFactory", "sf"]
}
