// node_modules/css-doodle/css-doodle.min.js
!function() {
  "use strict";
  const e = [":", ";", ",", "(", ")", "[", "]", "{", "}", "π", "±", "+", "-", "*", "/", "%", '"', "'", "`", "@", "=", "^"], t = { escape: (e2) => "\\" == e2, space: (e2) => /[\r\n\t\s]/.test(e2), digit: (e2) => /^[0-9]$/.test(e2), sign: (e2) => /^[+-]$/.test(e2), dot: (e2) => "." == e2, quote: (e2) => /^["'`]$/.test(e2), symbol: (t2) => e.includes(t2), hexNum: (e2) => /^[0-9a-f]$/i.test(e2), hex: (e2, n2, r2) => "0" == e2 && t.letter(n2, "x") && t.hexNum(r2), expWithSign: (e2, n2, r2) => t.letter(e2, "e") && t.sign(n2) && t.digit(r2), exp: (e2, n2) => t.letter(e2, "e") && t.digit(n2), dots: (e2, n2) => t.dot(e2) && t.dot(n2), letter: (e2, t2) => String(e2).toLowerCase() == String(t2).toLowerCase(), comment: (e2, t2) => "/" == e2 && "*" == t2, inlineComment: (e2, t2) => "/" == e2 && "/" === t2, selfClosedTag: (e2, t2) => "/" == e2 && ">" == t2, closedTag: (e2, t2) => "<" == e2 && "/" == t2 };
  class n {
    constructor({ type: e2, value: t2, pos: n2, status: r2 }) {
      this.type = e2, this.value = t2, this.pos = n2, r2 && (this.status = r2);
    }
    isSymbol(...e2) {
      let t2 = "Symbol" == this.type;
      return e2.length ? e2.some((e3) => e3 === this.value) : t2;
    }
    isSpace() {
      return "Space" == this.type;
    }
    isNumber() {
      return "Number" == this.type;
    }
    isWord() {
      return "Word" == this.type;
    }
  }
  function r(e2) {
    let t2 = -1, n2 = e2.length, r2 = -1, i2 = 0;
    return { curr: (n3 = 0) => e2[t2 + n3], next(n3 = 1) {
      let s2 = e2[t2 += n3];
      return "\n" === s2 ? (i2++, r2 = 0) : r2 += n3, s2;
    }, end: () => t2 >= n2, get: () => ({ prev: e2[t2 - 1], curr: e2[t2 + 0], next: e2[t2 + 1], next2: e2[t2 + 2], next3: e2[t2 + 3], pos: [r2, i2] }) };
  }
  function i(e2) {
    for (; e2.next(); ) {
      let { curr: n2, prev: r2 } = e2.get();
      if (t.comment(n2, r2))
        break;
    }
  }
  function s(e2) {
    for (; e2.next() && "\n" !== e2.curr(); )
      ;
  }
  function l(e2) {
    return [":", ";", ",", "{", "}", "(", ")", "[", "]"].includes(e2);
  }
  function o(e2) {
    let n2 = "";
    for (; !e2.end(); ) {
      let { curr: r2, next: i2 } = e2.get();
      n2 += r2;
      let s2 = t.symbol(i2) || t.space(i2) || t.digit(i2);
      if (n2.length && s2 && !t.closedTag(r2, i2))
        break;
      e2.next();
    }
    return n2.trim();
  }
  function a(e2) {
    let n2 = "";
    for (; !e2.end(); ) {
      let { curr: r2, next: i2 } = e2.get();
      if (n2 += r2, !t.space(i2))
        break;
      e2.next();
    }
    return n2;
  }
  function u(e2) {
    let n2 = "", r2 = false;
    for (; !e2.end(); ) {
      let { curr: i2, next: s2, next2: l2, next3: o2 } = e2.get();
      if (n2 += i2, r2 && t.dot(s2))
        break;
      if (t.dot(i2) && (r2 = true), t.dots(s2, l2))
        break;
      if (t.expWithSign(s2, l2, o2))
        n2 += e2.next() + e2.next();
      else if (t.exp(s2, l2))
        n2 += e2.next();
      else if (!t.digit(s2) && !t.dot(s2))
        break;
      e2.next();
    }
    return n2;
  }
  function c(e2) {
    let n2 = "0x";
    for (e2.next(2); !e2.end(); ) {
      let { curr: r2, next: i2 } = e2.get();
      if (n2 += r2, !t.hexNum(i2))
        break;
      e2.next();
    }
    return n2;
  }
  function h(e2) {
    return e2[e2.length - 1];
  }
  function p(e2, p2 = {}) {
    let f2 = r(String(e2).trim()), d2 = [], m2 = [];
    for (; f2.next(); ) {
      let { prev: e3, curr: r2, next: g3, next2: v2, pos: y2 } = f2.get();
      if (t.comment(r2, g3))
        i(f2);
      else if (p2.ignoreInlineComment && t.inlineComment(r2, g3))
        s(f2);
      else if (t.hex(r2, g3, v2)) {
        let e4 = c(f2);
        d2.push(new n({ type: "Number", value: e4, pos: y2 }));
      } else if (t.digit(r2) || t.digit(g3) && t.dot(r2) && !t.dots(e3, r2)) {
        let e4 = u(f2);
        d2.push(new n({ type: "Number", value: e4, pos: y2 }));
      } else if (t.symbol(r2) && !t.selfClosedTag(r2, g3)) {
        let e4 = h(d2), i2 = t.digit(g3) || t.dot(g3) && t.digit(v2);
        if ("-" === r2 && i2 && (!e4 || !e4.isNumber())) {
          let e5 = u(f2);
          d2.push(new n({ type: "Number", value: e5, pos: y2 }));
          continue;
        }
        let s2 = { type: "Symbol", value: r2, pos: y2 };
        if (m2.length && t.escape(e4.value)) {
          d2.pop();
          let e5 = o(f2);
          e5.length && d2.push(new n({ type: "Word", value: e5, pos: y2 }));
        } else {
          if (t.quote(r2)) {
            h(m2) == r2 ? (m2.pop(), s2.status = "close") : (m2.push(r2), s2.status = "open");
          }
          d2.push(new n(s2));
        }
      } else if (t.space(r2)) {
        let e4 = a(f2), t2 = h(d2), { next: i2 } = f2.get();
        if (!m2.length && t2) {
          let n2 = t2.value, s2 = l(n2) && ")" !== n2, o2 = l(i2) && "(" !== i2;
          if (s2 || o2)
            continue;
          e4 = p2.preserveLineBreak ? r2 : " ";
        }
        d2.length && i2 && i2.trim() && d2.push(new n({ type: "Space", value: e4, pos: y2 }));
      } else {
        let e4 = o(f2);
        e4.length && d2.push(new n({ type: "Word", value: e4, pos: y2 }));
      }
    }
    let g2 = h(d2);
    return g2 && g2.isSpace() && (d2.length = d2.length - 1), d2;
  }
  function f(e2) {
    let t2 = [];
    for (; e2.next(); ) {
      let { curr: n2, next: r2 } = e2.get();
      if ("var" === n2.value) {
        if (r2 && r2.isSymbol("(")) {
          e2.next();
          let n3 = d(e2);
          g(n3.name) && t2.push(n3);
        }
      } else if (t2.length && !n2.isSymbol(","))
        break;
    }
    return t2;
  }
  function d(e2) {
    let t2 = {}, n2 = [];
    for (; e2.next(); ) {
      let { curr: r2, next: i2 } = e2.get();
      if (r2.isSymbol(")", ";") && !t2.name) {
        t2.name = m(n2);
        break;
      }
      r2.isSymbol(",") ? (void 0 === t2.name && (t2.name = m(n2), n2 = []), t2.name && (t2.fallback = f(e2))) : n2.push(r2);
    }
    return t2;
  }
  function m(e2) {
    return e2.map((e3) => e3.value).join("");
  }
  function g(e2) {
    return void 0 !== e2 && (!(e2.length <= 2) && (!e2.substr(2).startsWith("-") && !!e2.startsWith("--")));
  }
  function v(e2, t2, n2) {
    return e2 = Number(e2) || 0, Math.max(t2, Math.min(n2, e2));
  }
  function y(e2, t2) {
    for (let [n2, r2] of Object.entries(t2))
      e2[n2] = e2[r2];
    return e2;
  }
  function b(e2) {
    return /^[a-zA-Z]$/.test(e2);
  }
  function x(e2) {
    return null == e2;
  }
  function _(e2) {
    return x(e2) || Number.isNaN(e2);
  }
  function $(e2) {
    return x(e2) || "" === e2;
  }
  function w(e2) {
    let t2 = (t3) => (...n2) => e2(t3, ...n2);
    return t2.lazy = true, t2;
  }
  function k(e2, t2, n2) {
    return "c-" + e2 + "-" + t2 + "-" + n2;
  }
  function S(e2) {
    let t2 = e2;
    for (; t2 && !x(t2.value); )
      t2 = t2.value;
    return x(t2) ? "" : t2;
  }
  function j(e2, t2, n2 = 0) {
    let r2 = new Image();
    r2.crossOrigin = "anonymous", r2.src = e2, r2.onload = function() {
      setTimeout(t2, n2);
    };
  }
  function A() {
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  }
  function N(e2) {
    let t2 = document.createElement("textarea");
    return t2.innerHTML = e2, t2.value;
  }
  function E(e2, t2 = 0) {
    let n2 = 3735928559 ^ t2, r2 = 1103547991 ^ t2;
    for (let t3, i2 = 0; i2 < e2.length; i2++)
      t3 = e2.charCodeAt(i2), n2 = Math.imul(n2 ^ t3, 2654435761), r2 = Math.imul(r2 ^ t3, 1597334677);
    return n2 = Math.imul(n2 ^ n2 >>> 16, 2246822507) ^ Math.imul(r2 ^ r2 >>> 13, 3266489909), r2 = Math.imul(r2 ^ r2 >>> 16, 2246822507) ^ Math.imul(n2 ^ n2 >>> 13, 3266489909), 4294967296 * (2097151 & r2) + (n2 >>> 0);
  }
  function T(e2, t2, n2) {
    return t2 + e2 * (n2 - t2);
  }
  function R(e2 = "") {
    return e2 + Math.random().toString(32).substr(2);
  }
  function z(e2) {
    return x(e2) ? [] : Array.isArray(e2) ? e2 : [e2];
  }
  function C(e2, t2 = "\n") {
    return (e2 || []).join(t2);
  }
  function M(e2, t2 = 1) {
    return x(e2) ? "" : e2[e2.length - t2];
  }
  function P(e2) {
    return e2[0];
  }
  function O(e2, t2 = { symbol: ",", noSpace: false, verbose: false }) {
    let n2 = [], i2 = [], s2 = [], l2 = [], o2 = "";
    if ($(e2))
      return n2;
    let a2 = r(p(e2));
    function u2(e3) {
      let n3 = t2.symbol || [","];
      return Array.isArray(n3) || (n3 = [n3]), t2.noSpace ? e3.isSymbol(...n3) : e3.isSymbol(...n3) || e3.isSpace();
    }
    function c2(e3) {
      let r2 = function(e4) {
        return e4.map((e5) => e5.value).join("");
      }(e3);
      t2.verbose ? (o2.length || r2.length) && n2.push({ group: o2, value: r2 }) : n2.push(r2);
    }
    for (; a2.next(); ) {
      let { prev: e3, curr: n3, next: r2 } = a2.get();
      n3.isSymbol("(") && s2.push(n3.value), n3.isSymbol(")") && s2.pop(), "open" === n3.status && l2.push(n3.value), "close" === n3.status && l2.pop();
      let h2 = !s2.length && !l2.length;
      if (h2) {
        let i3 = t2.noSpace && n3.isSpace() && u2(r2), s3 = t2.noSpace && n3.isSpace() && u2(e3);
        if (i3 || s3)
          continue;
      }
      h2 && u2(n3) ? (c2(i2), o2 = n3.value, i2 = []) : i2.push(n3);
    }
    return i2.length && c2(i2), n2;
  }
  function I(e2, t2) {
    let n2, r2 = [], i2 = [], s2 = [], l2 = false;
    for (; e2.next(); ) {
      let { curr: t3, next: o2 } = e2.get();
      t3.isSymbol("(") && !i2.length ? s2.push(t3) : t3.isSymbol(")") && !i2.length && s2.pop(), t3.isSymbol("'", '"') && ("open" === t3.status ? i2.push(t3) : i2.pop());
      let a2 = !i2.length && !s2.length && (!o2 || t3.isSymbol(";") || o2.isSymbol("}"));
      if (t3.isSymbol("'", '"') && o2 && o2.isSymbol("}") && !i2.length && (a2 = true), !s2.length && !i2.length && t3.isSymbol("{")) {
        let t4 = X(r2);
        if (!t4.length)
          continue;
        let i3 = t4.pop(), s3 = Y(...t4, i3);
        for (n2 = U(L(e2, H(i3, { type: "block", name: i3, value: [] })), s3); i3 = t4.pop(); )
          n2 = U(H(i3, { type: "block", name: i3, value: [n2] }), s3);
        l2 = true;
        break;
      }
      if (r2.push(t3), a2)
        break;
    }
    return r2.length && !n2 ? (t2._valueTokens = r2, t2.value = B(r2)) : n2 && (t2.value = n2), l2 && (t2.value.inline = true), t2.origin && (t2.origin.value = t2.value), t2;
  }
  function W(e2) {
    let t2 = [], n2 = [];
    for (; e2.next(); ) {
      let { curr: r2 } = e2.get();
      if (r2.isSymbol("{"))
        t2.push(r2.value);
      else if (r2.isSymbol("}")) {
        if (!t2.length)
          break;
        t2.pop();
      }
      n2.push(r2.value);
    }
    return n2.join("");
  }
  function L(e2, t2) {
    let n2 = [], r2 = [], i2 = t2 && t2.type || "", s2 = [];
    for (; e2.next(); ) {
      let { prev: l2, curr: o2, next: a2 } = e2.get();
      o2.isSymbol("(") && s2.push(o2.value), o2.isSymbol(")") && s2.pop();
      let u2 = !a2 || o2.isSymbol("}");
      if (G(i2) && u2) {
        if (!a2 && n2.length && !o2.isSymbol("}")) {
          "string" == typeof n2[n2.length - 1].value && (n2[n2.length - 1].value += ";" + o2.value);
        }
        t2.value = n2;
        break;
      }
      if (o2.isSymbol("{")) {
        let i3 = X(r2);
        if (!i3.length)
          continue;
        Y(t2.name) && (i3 = [B(r2)]);
        let s3 = i3.pop(), l3 = Y(...i3, t2.name, s3);
        if ("style" === s3)
          n2.push({ type: "block", name: s3, value: W(e2) });
        else {
          let t3 = U(L(e2, H(s3, { type: "block", name: s3, value: [] })), l3);
          for (; s3 = i3.pop(); )
            t3 = U(H(s3, { type: "block", name: s3, value: [t3] }), l3);
          n2.push(t3);
        }
        r2 = [];
      } else if (o2.isSymbol(":") && !s2.length && !D(l2, a2) && r2.length) {
        let s3 = F(r2, (e3) => e3.isSymbol(",")), l3 = { type: "statement", name: "unkown", value: "" };
        s3.length > 1 && (l3.origin = { name: s3 });
        let o3 = I(e2, l3), a3 = O(o3.value), u3 = s3.length > 1 && a3.length === s3.length;
        s3.forEach((e3, t3) => {
          let r3 = Object.assign({}, o3, { name: e3 });
          /^\-\-/.test(e3) && (r3.variable = true), u3 && (r3.value = a3[t3]), /viewBox/i.test(e3) && (r3.detail = q(r3.value, r3._valueTokens)), delete r3._valueTokens, n2.push(r3);
        }), G(i2) && (t2.value = n2), r2 = [];
      } else
        o2.isSymbol(";") ? n2.length && r2.length && (n2[n2.length - 1].value += ";" + B(r2), r2 = []) : r2.push(o2);
    }
    return n2.length && G(i2) && (t2.value = n2), i2 ? t2 : n2;
  }
  function D(e2, t2) {
    let n2 = e2 && e2.value, r2 = t2 && t2.value;
    return ["xlink:actuate", "xlink:arcrole", "xlink:href", "xlink:role", "xlink:show", "xlink:title", "xlink:type", "xml:base", "xml:lang", "xml:space"].includes(n2 + ":" + r2);
  }
  function B(e2) {
    return e2.filter((t2, n2) => !t2.isSymbol(";", "}") || n2 !== e2.length - 1).map((e3) => e3.value).join("");
  }
  function U(e2, t2) {
    let n2 = e2.name || "", [r2, ...i2] = n2.split(/#/), s2 = i2[i2.length - 1];
    return r2 && s2 && !t2 && (e2.name = r2, e2.value.push({ type: "statement", name: "id", value: s2 })), e2;
  }
  function F(e2, t2) {
    let n2 = [], r2 = [];
    return e2.forEach((e3) => {
      t2(e3) ? (n2.push(B(r2)), r2 = []) : r2.push(e3);
    }), r2.length && n2.push(B(r2)), n2;
  }
  function X(e2) {
    let t2, n2 = [], i2 = r(e2);
    for (; i2.next(); ) {
      let { prev: e3, curr: r2, next: s2 } = i2.get(), l2 = e3 && s2 && "x" === r2.value && e3.isNumber() && s2.isNumber();
      !r2.isWord() || t2 || l2 ? n2[n2.length - 1] = (n2[n2.length - 1] + r2.value).trim() : n2.push(r2.value.trim()), r2.isSymbol() ? t2 = true : r2.isSpace() || (t2 = false);
    }
    return n2;
  }
  function q(e2, t2) {
    const n2 = { value: [] };
    let r2;
    if (!Array.isArray(t2))
      return n2;
    for (let e3 of t2)
      e3.isSpace() || e3.isSymbol(",", ";") || (n2.value.length < 4 && e3.isNumber() ? n2.value.push(Number(e3.value)) : e3.isNumber() && r2 ? (n2[r2] = Number(e3.value), r2 = null) : e3.isWord() && (r2 = e3.value));
    return n2;
  }
  function H(e2, t2) {
    let n2 = Object.assign({}, t2);
    if (/\*\s*[0-9]/.test(e2)) {
      let [t3, r2] = e2.split("*");
      r2 && (n2.times = r2.trim(), n2.pureName = t3.trim());
    }
    return n2;
  }
  function Y(...e2) {
    return e2.some((e3) => "style" === e3);
  }
  function G(e2) {
    return "block" === e2;
  }
  function V(e2, t2) {
    return function(e3) {
      let t3, n2 = [];
      for (let r2 of e3.value)
        "svg" === r2.name && (t3 = r2), r2.variable && n2.push(r2);
      if (t3 && Array.isArray(t3.value)) {
        for (let e4 of n2)
          t3.value.find((t4) => t4.name == e4.name) || t3.value.unshift(e4);
        return t3;
      }
      return e3;
    }(L(r(p(e2)), t2 || { type: "block", name: "svg", value: [] }));
  }
  function Z(e2, t2) {
    let n2 = "";
    if ("block" === e2.type) {
      let t3 = Array.isArray(e2.value) && e2.value[0] && e2.value[0].inline;
      if (e2.times ? n2 += "@M" + e2.times + "(" + e2.pureName + "{" : n2 += e2.name + "{", "style" === e2.name)
        n2 += e2.value;
      else if (Array.isArray(e2.value) && e2.value.length) {
        let t4 = "";
        for (let r2 of e2.value)
          n2 += Z(r2, t4), r2.origin && (t4 = r2.origin.name.join(","));
      }
      e2.times ? n2 += "})" : t3 || (n2 += "}");
    } else if ("statement" === e2.type) {
      let r2 = e2.origin && t2 === e2.origin.name.join(","), i2 = e2.origin ? e2.origin.name.join(",") : e2.name, s2 = e2.origin ? e2.origin.value : e2.value;
      r2 || (n2 += s2 && s2.type ? i2 + ":" + Z(s2) : i2 + ":" + s2 + ";");
    }
    return n2;
  }
  function K(e2) {
    return Z(e2).trim();
  }
  const J = { func: (e2 = "") => ({ type: "func", name: e2, arguments: [] }), argument: () => ({ type: "argument", value: [] }), text: (e2 = "") => ({ type: "text", value: e2 }), pseudo: (e2 = "") => ({ type: "pseudo", selector: e2, styles: [] }), cond: (e2 = "") => ({ type: "cond", name: e2, styles: [], arguments: [] }), rule: (e2 = "") => ({ type: "rule", property: e2, value: [] }), keyframes: (e2 = "") => ({ type: "keyframes", name: e2, steps: [] }), step: (e2 = "") => ({ type: "step", name: e2, styles: [] }) }, Q = { white_space: (e2) => /[\s\n\t]/.test(e2), line_break: (e2) => /\n/.test(e2), number: (e2) => !isNaN(e2), pair: (e2) => ['"', "(", ")", "'"].includes(e2), pair_of: (e2, t2) => ({ '"': '"', "'": "'", "(": ")" })[e2] == t2 }, ee = { π: Math.PI, "∏": Math.PI };
  function te(e2) {
    return /^@(canvas|shaders|doodle)/.test(e2);
  }
  function ne(e2 = "") {
    let t2 = 0, n2 = 1, r2 = 1;
    return { curr: (n3 = 0) => e2[t2 + n3], end: () => e2.length <= t2, info: () => ({ index: t2, col: n2, line: r2 }), index: (e3) => void 0 === e3 ? t2 : t2 = e3, range: (t3, n3) => e2.substring(t3, n3), next() {
      let i2 = e2[t2++];
      return "\n" == i2 ? (r2++, n2 = 0) : n2++, i2;
    } };
  }
  function re(e2, { col: t2, line: n2 }) {
    console.warn(`(at line ${n2}, column ${t2}) ${e2}`);
  }
  function ie(e2) {
    return function(t2, n2) {
      let r2 = t2.index(), i2 = "";
      for (; !t2.end(); ) {
        let n3 = t2.next();
        if (e2(n3))
          break;
        i2 += n3;
      }
      return n2 && t2.index(r2), i2;
    };
  }
  function se(e2, t2) {
    return ie((e3) => /[^\w@]/.test(e3))(e2, t2);
  }
  function le(e2) {
    return ie((e3) => /[\s\{]/.test(e3))(e2);
  }
  function oe(e2, t2) {
    return ie((e3) => Q.line_break(e3) || "{" == e3)(e2, t2);
  }
  function ae(e2, t2) {
    let n2, r2 = J.step();
    for (; !e2.end() && "}" != (n2 = e2.curr()); )
      if (Q.white_space(n2))
        e2.next();
      else {
        if (r2.name.length) {
          if (r2.styles.push(ke(e2, t2)), "}" == e2.curr())
            break;
        } else
          r2.name = xe(e2, (e3) => "{" === e3);
        e2.next();
      }
    return r2;
  }
  function ue(e2, t2) {
    const n2 = [];
    let r2;
    for (; !e2.end() && "}" != (r2 = e2.curr()); )
      Q.white_space(r2) || n2.push(ae(e2, t2)), e2.next();
    return n2;
  }
  function ce(e2, t2) {
    let n2, r2 = J.keyframes();
    for (; !e2.end() && "}" != (n2 = e2.curr()); )
      if (r2.name.length) {
        if ("{" == n2 || "{" == e2.curr(-1)) {
          e2.next(), r2.steps = ue(e2, t2);
          break;
        }
        e2.next();
      } else if (se(e2), r2.name = le(e2), !r2.name.length) {
        re("missing keyframes name", e2.info());
        break;
      }
    return r2;
  }
  function he(e2, t2 = {}) {
    for (e2.next(); !e2.end(); ) {
      let n2 = e2.curr();
      if (t2.inline) {
        if ("\n" == n2)
          break;
      } else if ("*" == (n2 = e2.curr()) && "/" == e2.curr(1))
        break;
      e2.next();
    }
    t2.inline || (e2.next(), e2.next());
  }
  function pe(e2) {
    for (e2.next(); !e2.end(); ) {
      if (">" == e2.curr())
        break;
      e2.next();
    }
  }
  function fe(e2) {
    let t2, n2 = "";
    for (; !e2.end() && ":" != (t2 = e2.curr()); )
      Q.white_space(t2) || (n2 += t2), e2.next();
    return n2;
  }
  function de(e2, t2, n2, r2 = {}) {
    let i2, s2 = [], l2 = [], o2 = [], a2 = "", u2 = "";
    for (; !e2.end(); ) {
      i2 = e2.curr();
      let h2 = e2.curr(-1), p2 = e2.index();
      if (/[\('"`]/.test(i2) && "\\" !== h2)
        o2.length && "(" !== i2 && i2 === M(o2) ? o2.pop() : o2.push(i2), a2 += i2;
      else if (!n2 && ("@" == i2 || "$" === i2 || "." === h2 && t2))
        l2.length || (a2 = a2.trimLeft()), a2.length && (l2.push(J.text(a2)), a2 = ""), l2.push(be(e2, r2));
      else if (n2 && /[)]/.test(i2) || !n2 && /[,)]/.test(i2))
        if (o2.length)
          ")" == i2 && "(" === M(o2) && o2.pop(), a2 += i2;
        else {
          if (a2.length && (l2.length ? /\S/.test(a2) && l2.push(J.text(a2)) : l2.push(J.text((c2 = a2).trim().length ? Q.number(+c2) ? +c2 : c2.trim() : c2)), a2.startsWith("±") && !n2)) {
            let e3 = a2.substr(1), t3 = structuredClone(l2);
            M(t3).value = "-" + e3, s2.push(ge(t3)), M(l2).value = e3;
          }
          if (s2.push(ge(l2)), [l2, a2] = [[], ""], ")" == i2)
            break;
        }
      else
        ee[i2] && !/[0-9]/.test(e2.curr(-1)) && (i2 = ee[i2]), a2 += i2;
      if (!(!t2 || ")" != e2.curr(1) && ";" != e2.curr(1) && /[0-9a-zA-Z_\-.]/.test(e2.curr()) || o2.length)) {
        l2.length && s2.push(ge(l2));
        break;
      }
      u2 += e2.range(p2, e2.index() + 1), e2.next();
    }
    var c2;
    return [me(s2), u2];
  }
  function me(e2) {
    let t2 = M(e2[0]);
    return t2 && "text" === t2.type && !String(t2.value).trim().length && (e2[0] = e2[0].slice(0, -1)), e2;
  }
  function ge(e2) {
    let t2 = e2.map((e3) => {
      if ("text" == e3.type && "string" == typeof e3.value) {
        let t3 = String(e3.value);
        t3.includes("`") && (e3.value = t3 = t3.replace(/`/g, '"')), e3.value = t3;
      }
      return e3;
    }), n2 = P(t2) || {}, r2 = M(t2) || {};
    if ("text" == n2.type && "text" == r2.type) {
      let e3 = P(n2.value), i2 = M(r2.value);
      "string" == typeof n2.value && "string" == typeof r2.value && Q.pair_of(e3, i2) && (n2.value = n2.value.slice(1), r2.value = r2.value.slice(0, r2.value.length - 1), t2.cluster = true);
    }
    return t2;
  }
  function ve(e2) {
    let t2 = JSON.stringify(e2);
    return t2.includes("pureName") && t2.includes("times");
  }
  function ye(e2) {
    return /^@svg$/i.test(e2);
  }
  function be(e2, t2 = {}) {
    let n2, r2 = J.func(), i2 = e2.curr(), s2 = false, l2 = "$" === i2;
    for ("@" === i2 ? e2.next() : i2 = "@"; !e2.end(); ) {
      n2 = e2.curr();
      let l3 = e2.curr(1), o3 = "." == n2 && /[a-zA-Z@$]/.test(l3);
      if ("(" == n2 || o3) {
        s2 = true, e2.next();
        let [n3, l4] = de(e2, o3, te(i2), t2);
        if (ye(i2)) {
          let e3 = V(l4), r3 = 0;
          for (let n4 of e3.value)
            n4.variable && (t2[n4.name] = Ee(`${"\n".repeat(r3++)} ${n4.name}:${n4.value}`)[0].value);
          if (/\d\s*{/.test(l4) && ve(e3)) {
            let r4 = K(e3);
            r4 += ")", n3 = de(ne(r4), o3, te(i2), t2)[0];
          }
        }
        r2.arguments = n3, r2.variables = t2;
        break;
      }
      if (/[0-9a-zA-Z_\-.%]/.test(n2) && (i2 += n2), !s2 && "(" !== l3 && !/[0-9a-zA-Z_\-.%]/.test(l3))
        break;
      e2.next();
    }
    let { fname: o2, extra: a2 } = function(e3) {
      let t3 = "", n3 = "";
      if (/\D$/.test(e3) && !/\d+[x-]\d+/.test(e3) || Math[e3.substr(1)])
        return { fname: e3, extra: n3 };
      for (let r3 = e3.length - 1; r3 >= 0; r3--) {
        let i3 = e3[r3], s3 = e3[r3 - 1], l3 = e3[r3 + 1];
        if (!(/[\d.]/.test(i3) || ("x" == i3 || "-" == i3) && /\d/.test(s3) && /\d/.test(l3))) {
          t3 = e3.substring(0, r3 + 1);
          break;
        }
        n3 = i3 + n3;
      }
      return { fname: t3, extra: n3 };
    }(i2);
    if (r2.name = l2 ? "@$" + i2.substr(1) : o2, a2.length && r2.arguments.unshift([{ type: "text", value: a2 }]), l2 && r2.name.length > 2) {
      if (!r2.arguments.length) {
        let e3 = r2.name.substring(0, 2), t3 = r2.name.substring(2);
        r2.name = e3, r2.arguments.push([{ type: "text", value: t3 }]);
      }
      if (/\d$/.test(r2.name)) {
        let e3 = r2.name.substring(0, 2), t3 = r2.name.substring(2);
        r2.name = e3, r2.arguments[0][0].value = t3;
      }
    }
    return r2.position = e2.info().index, r2;
  }
  function xe(e2, t2 = () => {
  }) {
    let n2, r2 = J.text(), i2 = 0, s2 = true;
    const l2 = [];
    l2[i2] = [];
    let o2 = [], a2 = [];
    for (; !e2.end(); ) {
      if (n2 = e2.curr(), s2 && Q.white_space(n2)) {
        e2.next();
        continue;
      }
      if (s2 = false, "\n" != n2 || Q.white_space(e2.curr(-1)))
        if ("," != n2 || o2.length) {
          if ((/[;}<]/.test(n2) || t2(n2)) && !a2.length) {
            r2.value.length && (l2[i2].push(r2), r2 = J.text());
            break;
          }
          if ("@" !== n2 && "$" !== n2 || !/[\w-\(%]/.test(e2.curr(1)))
            if ('"' === n2 || "'" === n2) {
              n2 === M(a2) ? a2.pop() : a2.length || a2.push(n2), r2.value += n2;
            } else
              Q.white_space(n2) && Q.white_space(e2.curr(-1)) || ("(" == n2 && o2.push(n2), ")" == n2 && o2.pop(), ee[n2] && !/[0-9]/.test(e2.curr(-1)) && (n2 = ee[n2]), r2.value += n2);
          else
            r2.value.length && (l2[i2].push(r2), r2 = J.text()), l2[i2].push(be(e2));
        } else
          r2.value.length && (l2[i2].push(r2), r2 = J.text()), l2[++i2] = [], s2 = true;
      else
        r2.value += " ";
      let u2 = e2.curr();
      if ((";" === u2 || "}" == u2 || t2(u2)) && !a2.length)
        break;
      e2.next();
    }
    return r2.value.length && l2[i2].push(r2), l2;
  }
  function _e(e2) {
    let t2, n2 = "";
    for (; !e2.end() && "{" != (t2 = e2.curr()); )
      n2 += t2, e2.next();
    return n2 = n2.trim(), n2;
  }
  function $e(e2) {
    let t2, n2 = { name: "", arguments: [] };
    for (; !e2.end(); ) {
      if ("(" == (t2 = e2.curr()))
        e2.next(), n2.arguments = de(e2)[0];
      else {
        if (/[){]/.test(t2))
          break;
        n2.name += t2;
      }
      e2.next();
    }
    let [r2, ...i2] = n2.name.trim().split(/\s+/);
    return n2.name = r2, n2.addition = i2, n2;
  }
  function we(e2, t2) {
    let n2, r2 = J.pseudo();
    for (; !e2.end(); ) {
      if (n2 = e2.curr(), "/" == n2 && "*" == e2.curr(1))
        he(e2);
      else {
        if ("}" == n2)
          break;
        if (Q.white_space(n2)) {
          e2.next();
          continue;
        }
        if (r2.selector) {
          let n3 = ke(e2, t2);
          if ("@use" == n3.property ? r2.styles = r2.styles.concat(n3.value) : n3.property && r2.styles.push(n3), "}" == e2.curr())
            break;
        } else
          r2.selector = _e(e2);
      }
      e2.next();
    }
    return r2;
  }
  function ke(e2, t2) {
    let n2, r2 = J.rule(), i2 = e2.index();
    for (; !e2.end(); ) {
      if (n2 = e2.curr(), "/" == n2 && "*" == e2.curr(1))
        he(e2);
      else {
        if (";" == n2)
          break;
        if (r2.property.length) {
          r2.value = xe(e2);
          break;
        }
        if (r2.property = fe(e2), "@use" == r2.property) {
          r2.value = Ne(e2, t2);
          break;
        }
      }
      e2.next();
    }
    let s2 = e2.index();
    return r2.raw = () => e2.range(i2, s2).trim(), r2;
  }
  function Se(e2, t2) {
    let n2, r2 = J.cond();
    for (; !e2.end(); ) {
      if (n2 = e2.curr(), "/" == n2 && "*" == e2.curr(1))
        he(e2);
      else {
        if ("}" == n2)
          break;
        if (r2.name.length)
          if (":" == n2) {
            let t3 = we(e2);
            t3.selector && r2.styles.push(t3);
          } else if ("@" != n2 || oe(e2, true).includes(":")) {
            if (!Q.white_space(n2)) {
              let n3 = ke(e2, t2);
              if (n3.property && r2.styles.push(n3), "}" == e2.curr())
                break;
            }
          } else
            r2.styles.push(Se(e2));
        else
          Object.assign(r2, $e(e2));
      }
      e2.next();
    }
    return r2;
  }
  function je(e2, t2) {
    let n2 = "";
    return e2 && e2.get_variable && (n2 = e2.get_variable(t2)), n2;
  }
  function Ae(e2, t2) {
    e2.forEach && e2.forEach((e3) => {
      if ("text" == e3.type && e3.value) {
        let n2 = f(r(p(e3.value)));
        e3.value = n2.reduce((e4, n3) => {
          let r2, i2 = "", s2 = "";
          i2 = je(t2, n3.name), !i2 && n3.fallback && n3.fallback.every((e5) => {
            if (s2 = je(t2, e5.name), s2)
              return i2 = s2, false;
          });
          try {
            r2 = Ee(i2, t2);
          } catch (e5) {
          }
          return r2 && e4.push.apply(e4, r2), e4;
        }, []);
      }
      "func" == e3.type && e3.arguments && e3.arguments.forEach((e4) => {
        Ae(e4, t2);
      });
    });
  }
  function Ne(e2, t2) {
    return e2.next(), (xe(e2) || []).reduce((e3, n2) => {
      Ae(n2, t2);
      let [r2] = n2;
      return r2.value && r2.value.length && e3.push(...r2.value), e3;
    }, []);
  }
  function Ee(e2, t2) {
    const n2 = ne(e2), r2 = [];
    for (; !n2.end(); ) {
      let e3 = n2.curr();
      if (Q.white_space(e3))
        n2.next();
      else {
        if ("/" == e3 && "*" == n2.curr(1))
          he(n2);
        else if (":" == e3) {
          let e4 = we(n2, t2);
          e4.selector && r2.push(e4);
        } else if ("@" == e3 && "@keyframes" === se(n2, true)) {
          let e4 = ce(n2, t2);
          r2.push(e4);
        } else if ("@" != e3 || oe(n2, true).includes(":")) {
          if ("<" == e3)
            pe(n2);
          else if (!Q.white_space(e3)) {
            let e4 = ke(n2, t2);
            e4.property && r2.push(e4);
          }
        } else {
          let e4 = Se(n2, t2);
          e4.name.length && r2.push(e4);
        }
        n2.next();
      }
    }
    return r2;
  }
  function Te(e2, t2 = 64) {
    const [n2, r2, i2] = [1, t2, t2 * t2];
    let [s2, l2, o2] = (e2 + "").replace(/\s+/g, "").replace(/[,\uff0cxX]+/g, "x").split("x").map((e3) => parseInt(e3));
    const a2 = 1 == s2 || 1 == l2 ? i2 : r2, u2 = 1 == s2 && 1 == l2 ? i2 : n2, c2 = { x: v(s2 || n2, 1, a2), y: v(l2 || s2 || n2, 1, a2), z: v(o2 || n2, 1, u2) };
    return Object.assign({}, c2, { count: c2.x * c2.y * c2.z, ratio: c2.x / c2.y });
  }
  function Re(e2) {
    return /^texture\w*$|^(fragment|vertex)$/.test(e2);
  }
  function ze() {
    return new n({ type: "LineBreak", value: "\n" });
  }
  function Ce(e2) {
    let t2 = e2[0], n2 = e2[e2.length - 1];
    for (; t2 && t2.isSymbol("(") && n2 && n2.isSymbol(")"); )
      t2 = (e2 = e2.slice(1, e2.length - 1))[0], n2 = e2[e2.length - 1];
    return e2;
  }
  function Me(e2) {
    return Ce(e2).map((e3) => e3.value).join("");
  }
  const Pe = 'xmlns="http://www.w3.org/2000/svg"', Oe = 'xmlns="http://www.w3.org/1999/xhtml"', Ie = 'xmlns:xlink="http://www.w3.org/1999/xlink"';
  function We(e2, t2) {
    return `url("data:image/svg+xml;utf8,${encodeURIComponent(e2) + (t2 ? `#${t2}` : "")}")`;
  }
  function Le(e2) {
    return e2.includes("<svg") || (e2 = `<svg ${Pe} ${Ie}>${e2}</svg>`), e2.includes("xmlns") || (e2 = e2.replace(/<svg([\s>])/, `<svg ${Pe} ${Ie}$1`)), e2;
  }
  function De(e2) {
    let t2 = r(p(e2)), n2 = {}, i2 = false;
    for (; t2.next(); ) {
      let { prev: e3, curr: r2, next: s2 } = t2.get(), l2 = i2 && (r2.isWord() || r2.isSymbol()) && e3 && e3.isNumber() && !s2;
      if (r2.isNumber())
        n2.value = Number(r2.value), i2 = true;
      else {
        if (!l2)
          break;
        n2.unit = r2.value;
      }
    }
    return n2;
  }
  function Be(e2) {
    return (...t2) => {
      let n2 = [], r2 = [];
      for (let e3 of t2) {
        let { unit: t3, value: i3 } = De(e3);
        void 0 !== t3 && n2.push(t3), void 0 !== i3 && r2.push(i3);
      }
      let i2 = e2(...r2), s2 = n2.find((e3) => void 0 !== e3);
      return void 0 === s2 ? i2 : Array.isArray(i2) ? i2.map((e3) => e3 + s2) : i2 + s2;
    };
  }
  function Ue(e2) {
    return (...t2) => {
      let n2 = t2.map((e3) => String(e3).charCodeAt(0)), r2 = e2(...n2);
      return Array.isArray(r2) ? r2.map((e3) => String.fromCharCode(e3)) : String.fromCharCode(r2);
    };
  }
  var Fe = new class {
    constructor() {
      this.cache = {};
    }
    clear() {
      this.cache = {};
    }
    set(e2, t2) {
      if (x(e2))
        return "";
      let n2 = this.getKey(e2);
      return this.cache[n2] = t2;
    }
    get(e2) {
      let t2 = this.getKey(e2);
      return this.cache[t2];
    }
    getKey(e2) {
      return E("string" == typeof e2 ? e2 : JSON.stringify(e2));
    }
  }();
  function Xe(e2, t2) {
    return (...n2) => {
      let r2 = e2 + n2.join("-");
      return Fe.get(r2) || Fe.set(r2, t2(...n2));
    };
  }
  function qe(e2, t2) {
    return { type: e2, value: t2 };
  }
  function He(e2, t2, n2) {
    let r2 = 0, i2 = e2, s2 = (e3) => e3 > 0 && e3 < 1 ? 0.1 : 1, l2 = arguments.length;
    1 == l2 && ([e2, t2] = [s2(e2), e2]), l2 < 3 && (n2 = s2(e2));
    let o2 = [];
    for (; (n2 >= 0 && e2 <= t2 || n2 < 0 && e2 > t2) && (o2.push(e2), e2 += n2, !(r2++ >= 65535)); )
      ;
    return o2.length || o2.push(i2), o2;
  }
  const Ye = Xe("build_range", (e2) => {
    let t2 = function(e3) {
      let t3 = String(e3), n2 = [], r2 = [];
      if (!t3.startsWith("[") || !t3.endsWith("]"))
        return n2;
      for (let e4 = 1; e4 < t3.length - 1; ++e4) {
        let i2 = t3[e4];
        if ("-" != i2 || "-" != t3[e4 - 1])
          if ("-" != i2)
            if ("-" != M(r2))
              r2.length && n2.push(qe("char", r2.pop())), r2.push(i2);
            else {
              r2.pop();
              let e5 = r2.pop();
              n2.push(e5 ? qe("range", [e5, i2]) : qe("char", i2));
            }
          else
            r2.push(i2);
      }
      return r2.length && n2.push(qe("char", r2.pop())), n2;
    }(e2);
    return t2.flatMap(({ type: e3, value: t3 }) => {
      if ("char" == e3)
        return t3;
      let [n2, r2] = t3, i2 = false;
      n2 > r2 && ([n2, r2] = [r2, n2], i2 = true);
      let s2 = Ue(He)(n2, r2);
      return i2 && s2.reverse(), s2;
    });
  });
  function Ge(e2) {
    return (...t2) => e2(...t2.flatMap((e3) => String(e3).startsWith("[") ? Ye(e3) : e3));
  }
  class Ve {
    constructor(e2) {
      this.prev = this.next = null, this.data = e2;
    }
  }
  class Ze {
    constructor(e2 = 20) {
      this._limit = e2, this._size = 0;
    }
    push(e2) {
      this._size >= this._limit && (this.root = this.root.next, this.root.prev = null);
      let t2 = new Ve(e2);
      this.root ? (t2.prev = this.tail, this.tail.next = t2, this.tail = t2) : this.root = this.tail = t2, this._size++;
    }
    last(e2 = 1) {
      let t2 = this.tail;
      for (; --e2 && t2.prev; )
        t2 = t2.prev;
      return t2.data;
    }
  }
  const Ke = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180];
  class Je {
    constructor() {
      this.p = [].concat(Ke, Ke);
    }
    grad(e2, t2, n2, r2) {
      let i2 = 15 & e2, s2 = i2 < 8 ? t2 : n2, l2 = i2 < 4 ? n2 : 12 == i2 || 14 == i2 ? t2 : r2;
      return (0 == (1 & i2) ? s2 : -s2) + (0 == (2 & i2) ? l2 : -l2);
    }
    noise(e2, t2, n2) {
      let { p: r2, grad: i2 } = this, [s2, l2, o2] = [e2, t2, n2].map((e3) => 255 & Math.floor(e3));
      [e2, t2, n2] = [e2, t2, n2].map((e3) => e3 - Math.floor(e3));
      let [a2, u2, c2] = [e2, t2, n2].map((e3) => e3 * e3 * e3 * (e3 * (6 * e3 - 15) + 10)), h2 = r2[s2] + l2, p2 = r2[h2] + o2, f2 = r2[h2 + 1] + o2, d2 = r2[s2 + 1] + l2, m2 = r2[d2] + o2, g2 = r2[d2 + 1] + o2;
      return T(c2, T(u2, T(a2, i2(r2[p2], e2, t2, n2), i2(r2[m2], e2 - 1, t2, n2)), T(a2, i2(r2[f2], e2, t2 - 1, n2), i2(r2[g2], e2 - 1, t2 - 1, n2))), T(u2, T(a2, i2(r2[p2 + 1], e2, t2, n2 - 1), i2(r2[m2 + 1], e2 - 1, t2, n2 - 1)), T(a2, i2(r2[f2 + 1], e2, t2 - 1, n2 - 1), i2(r2[g2 + 1], e2 - 1, t2 - 1, n2 - 1))));
    }
  }
  function Qe(e2, t2) {
    let n2 = {}, r2 = true;
    for (let i2 = 0; i2 < e2.length; ++i2) {
      let s2 = e2[i2], l2 = t2[i2];
      if (/=/.test(s2)) {
        let [e3, i3] = O(s2, { symbol: "=", noSpace: true });
        void 0 !== i3 ? (t2.includes(e3) && (n2[e3] = i3), r2 = false) : n2[l2] = s2;
      } else
        r2 && (n2[l2] = s2);
    }
    return n2;
  }
  const et = /* @__PURE__ */ new Map(), tt = { π: Math.PI, gcd: (e2, t2) => {
    for (; t2; )
      [e2, t2] = [t2, e2 % t2];
    return e2;
  } }, nt = { "^": 7, "*": 6, "/": 6, "÷": 6, "%": 6, "&": 5, "|": 5, "+": 4, "-": 4, "<": 3, "<<": 3, ">": 3, ">>": 3, "=": 3, "==": 3, "≤": 3, "<=": 3, "≥": 3, ">=": 3, "≠": 3, "!=": 3, "∧": 2, "&&": 2, "∨": 2, "||": 2, "(": 1, ")": 1 };
  function rt(e2, t2, n2 = []) {
    let r2 = [];
    for (; e2.length; ) {
      let { name: i2, value: s2, type: l2 } = e2.shift();
      if ("variable" === l2) {
        let e3 = t2[s2];
        _(e3) && (e3 = Math[s2]), _(e3) && (e3 = lt(s2, t2, n2)), _(e3) && /^\-\D/.test(s2) && (e3 = lt("-1" + s2.substr(1), t2, n2)), void 0 === e3 && (e3 = 0), "number" != typeof e3 && (n2.push(e3), ot(n2) ? (e3 = 0, n2 = []) : e3 = rt(it(e3), t2, n2)), r2.push(e3);
      } else if ("function" === l2) {
        let e3 = false;
        /^\-/.test(i2) && (e3 = true, i2 = i2.substr(1));
        let l3, o2 = s2.map((e4) => rt(e4, t2, n2)), a2 = i2.split(".");
        for (; l3 = a2.pop(); ) {
          if (!l3)
            continue;
          let e4 = t2[l3] || Math[l3];
          o2 = "function" == typeof e4 ? Array.isArray(o2) ? e4(...o2) : e4(o2) : 0;
        }
        e3 && (o2 *= -1), r2.push(o2);
      } else if (/\d+/.test(s2))
        r2.push(s2);
      else {
        let e3 = r2.pop(), t3 = r2.pop();
        r2.push(st(s2, Number(t3), Number(e3)));
      }
    }
    return Number(r2[0]) || 0;
  }
  function it(e2) {
    let t2 = function(e3) {
      if (et.has(e3))
        return et.get(e3);
      let t3 = String(e3), n3 = [], r3 = "";
      for (let e4 = 0; e4 < t3.length; ++e4) {
        let i2 = t3[e4];
        if (nt[i2]) {
          let s2 = M(n3);
          if ("=" == i2 && s2 && /^[!<>=]$/.test(s2.value))
            s2.value += i2;
          else if (/^[|&<>]$/.test(i2) && s2 && s2.value == i2)
            s2.value += i2;
          else if ("-" == i2 && "e" == t3[e4 - 1])
            r3 += i2;
          else if (n3.length || r3.length || !/[+-]/.test(i2)) {
            let { type: e5, value: t4 } = s2 || {};
            "operator" == e5 && !r3.length && /[^()]/.test(i2) && /[^()]/.test(t4) ? r3 += i2 : (r3.length && (n3.push({ type: "number", value: r3 }), r3 = ""), n3.push({ type: "operator", value: i2 }));
          } else
            r3 += i2;
        } else
          /\S/.test(i2) && ("," == i2 ? (n3.push({ type: "number", value: r3 }), r3 = "", n3.push({ type: "comma", value: i2 })) : "!" == i2 ? (n3.push({ type: "number", value: r3 }), n3.push({ type: "operator", value: i2 }), r3 = "") : r3 += i2);
      }
      return r3.length && n3.push({ type: "number", value: r3 }), et.set(e3, n3), n3;
    }(e2);
    const n2 = [], r2 = [];
    for (let e3 = 0; e3 < t2.length; ++e3) {
      let { type: i2, value: s2 } = t2[e3], l2 = t2[e3 + 1] || {};
      if ("number" == i2)
        if ("(" == l2.value && /[^\d.\-]/.test(s2)) {
          let n3 = "", i3 = [], l3 = [];
          for (e3 += 1; void 0 !== t2[e3++]; ) {
            let r3 = t2[e3];
            if (void 0 === r3)
              break;
            let s3 = r3.value;
            if (")" == s3) {
              if (!i3.length)
                break;
              i3.pop(), n3 += s3;
            } else if ("(" == s3 && i3.push(s3), "," != s3 || i3.length)
              n3 += s3;
            else {
              let e4 = it(n3);
              e4.length && l3.push(e4), n3 = "";
            }
          }
          n3.length && l3.push(it(n3)), r2.push({ type: "function", name: s2, value: l3 });
        } else
          /[^\d.\-]/.test(s2) ? r2.push({ type: "variable", value: s2 }) : r2.push({ type: "number", value: s2 });
      else if ("operator" == i2)
        if ("(" == s2)
          n2.push(s2);
        else if (")" == s2) {
          for (; n2.length && "(" != M(n2); )
            r2.push({ type: "operator", value: n2.pop() });
          n2.pop();
        } else {
          for (; n2.length && nt[M(n2)] >= nt[s2]; ) {
            let e4 = n2.pop();
            /[()]/.test(e4) || r2.push({ type: "operator", value: e4 });
          }
          n2.push(s2);
        }
    }
    for (; n2.length; )
      r2.push({ type: "operator", value: n2.pop() });
    return r2;
  }
  function st(e2, t2, n2) {
    switch (e2) {
      case "+":
        return t2 + n2;
      case "-":
        return t2 - n2;
      case "*":
        return t2 * n2;
      case "%":
        return t2 % n2;
      case "|":
        return t2 | n2;
      case "&":
        return t2 & n2;
      case "<":
        return t2 < n2;
      case ">":
        return t2 > n2;
      case "^":
        return Math.pow(t2, n2);
      case "÷":
      case "/":
        return t2 / n2;
      case "=":
      case "==":
        return t2 == n2;
      case "≤":
      case "<=":
        return t2 <= n2;
      case "≥":
      case ">=":
        return t2 >= n2;
      case "≠":
      case "!=":
        return t2 != n2;
      case "∧":
      case "&&":
        return t2 && n2;
      case "∨":
      case "||":
        return t2 || n2;
      case "<<":
        return t2 << n2;
      case ">>":
        return t2 >> n2;
    }
  }
  function lt(e2, t2, n2) {
    let [r2, i2, s2] = e2.match(/([\d.\-]+)(.*)/) || [], l2 = t2[s2];
    return void 0 === l2 ? l2 : "number" == typeof l2 ? Number(i2) * l2 : (n2.push(l2), ot(n2) ? (n2 = [], 0) : i2 * rt(it(l2), t2, n2));
  }
  function ot(e2) {
    if (e2.length > 50)
      return true;
    let t2 = M(e2);
    for (let n2 = 2; n2 <= 4; ++n2) {
      let r2 = e2[e2.length - n2];
      if (void 0 === r2)
        return false;
      if (t2 !== r2)
        return false;
    }
    return true;
  }
  function at(e2, t2) {
    return rt(it(e2), Object.assign({}, tt, t2));
  }
  const ut = { name: "cssd-utime", "animation-name": "cssd-utime-animation", "animation-duration": 31536e6, "animation-iteration-count": "infinite", "animation-delay": "0s", "animation-direction": "normal", "animation-fill-mode": "none", "animation-play-state": "running", "animation-timing-function": "linear" };
  ut.animation = `
 ${ut["animation-duration"]}ms
 ${ut["animation-timing-function"]} ${ut["animation-delay"]} ${ut["animation-iteration-count"]} ${ut["animation-name"]}`;
  const ct = "cssd-umousex", ht = "cssd-umousey", pt = "cssd-uwidth", ft = "cssd-uheight";
  function dt(e2) {
    let t2 = r(p(e2)), n2 = {}, i2 = { commands: [], valid: true };
    for (; t2.next(); ) {
      let { curr: e3 } = t2.get();
      if (!e3.isSpace() && !e3.isSymbol(","))
        if (e3.isWord())
          n2.name && (i2.commands.push(n2), n2 = {}), n2.name = e3.value, n2.value = [], "MmLlHhVvCcSsQqTtAaZz".includes(e3.value) ? "mlhvcsqtaz".includes(e3.value) ? n2.type = "relative" : n2.type = "absolute" : (n2.type = "unknown", i2.valid = false);
        else if (n2.value) {
          let t3 = e3.value;
          e3.isNumber() && (t3 = Number(e3.value)), n2.value.push(t3);
        } else
          n2.name || (i2.valid = false);
    }
    return n2.name && i2.commands.push(n2), i2;
  }
  const mt = /* @__PURE__ */ function() {
    let e2 = 0;
    return (t2 = "") => `${t2}-${++e2}`;
  }();
  class gt {
    constructor(e2, t2 = "") {
      if (!e2)
        throw new Error("Tag name is required");
      this.id = Symbol(), this.name = e2, this.body = [], this.attrs = {}, this.isTextNode() && (this.body = t2);
    }
    isTextNode() {
      return "text-node" === this.name;
    }
    find(e2) {
      let t2 = e2.attrs.id, n2 = e2.name;
      if (Array.isArray(this.body) && void 0 !== t2)
        return this.body.find((e3) => e3.attrs.id === t2 && e3.name === n2);
    }
    findSpareDefs() {
      return this.body.find((e2) => "defs" === e2.name && !e2.attrs.id);
    }
    append(e2) {
      Array.isArray(e2) || (e2 = [e2]);
      for (let t2 of e2)
        this.isTextNode() || this.body.push(t2);
    }
    merge(e2) {
      for (let [t2, n2] of Object.entries(e2.attrs))
        this.attrs[t2] = n2;
      Array.isArray(e2.body) && this.body.push(...e2.body);
    }
    attr(e2, t2) {
      if (!this.isTextNode())
        return void 0 === t2 ? this.attrs[e2] : this.attrs[e2] = t2;
    }
    toString() {
      if (this.isTextNode())
        return vt(this.body);
      let e2 = [""], t2 = [];
      for (let [t3, n2] of Object.entries(this.attrs))
        n2 = vt(n2), e2.push(`${t3}="${n2}"`);
      for (let e3 of this.body)
        t2.push(e3.toString());
      return t2.join("").length || /svg/i.test(this.name) ? `<${this.name}${e2.join(" ")}>${t2.join("")}</${this.name}>` : `<${this.name}${e2.join(" ")}/>`;
    }
  }
  function vt(e2) {
    let t2 = (e2 = String(e2)).startsWith('"') && e2.endsWith('"'), n2 = e2.startsWith("'") && e2.endsWith("'");
    return t2 || n2 ? e2.substring(1, e2.length - 1) : e2;
  }
  function yt(e2, t2, n2, r2) {
    let i2;
    if (t2 || (t2 = new gt("root")), "block" === e2.type)
      if ("style" === e2.name) {
        let n3 = new gt("style");
        n3.append(e2.value), t2.append(n3);
      } else {
        let s3 = new gt(e2.name);
        if (r2 || (r2 = s3).attr("xmlns", Pe.split("=")[1]), "defs" === e2.name) {
          let e3 = r2.findSpareDefs();
          e3 && (s3 = e3);
        }
        for (let t3 of e2.value) {
          e2.parent = n2;
          let l3 = yt(t3, s3, e2, r2);
          l3 && (i2 = l3);
        }
        let l2 = e2 && e2.inline && "defs" !== e2.name, o2 = n2 && n2.inline && "defs" === n2.name, a2 = o2 && 1 == n2.value.length;
        if (l2 || o2) {
          let t3 = e2.value.find((e3) => "statement" === e3.type && "id" === e3.name);
          t3 ? i2 = t3.value : (a2 || l2) && (i2 = mt(e2.name), s3.attr("id", i2));
        }
        let u2 = t2.find(s3);
        if (u2)
          u2.merge(s3);
        else if ("defs" === e2.name) {
          let e3 = r2.findSpareDefs();
          e3 && !s3.attrs.id ? s3.id !== e3.id && e3.append(s3.body) : r2.append(s3);
        } else
          t2.append(s3);
      }
    if ("statement" === e2.type && !e2.variable)
      if ("content" === e2.name) {
        let n3 = new gt("text-node", e2.value);
        t2.append(n3);
      } else if (e2.name.startsWith("style ")) {
        let n3 = (e2.name.split("style ")[1] || "").trim();
        if (n3.length) {
          let r3 = t2.attr("style") || "";
          t2.attr("style", r3 + function(e3, t3) {
            return `${e3}:${t3};`;
          }(n3, e2.value));
        }
      } else {
        let i3 = e2.value;
        if (i3 && "block" === i3.type) {
          let t3 = yt(e2.value, r2, e2, r2);
          x(t3) ? i3 = "" : (i3 = `url(#${t3})`, "xlink:href" !== e2.name && "href" !== e2.name || (i3 = `#${t3}`));
        }
        if (/viewBox/i.test(e2.name))
          i3 = function(e3) {
            let t3 = e3.detail.value, n3 = e3.detail.padding || e3.detail.p || e3.detail.expand;
            if (!t3.length)
              return "";
            let [r3, i4, s3, l2] = t3;
            return n3 && ([r3, i4, s3, l2] = [r3 - n3, i4 - n3, s3 + 2 * n3, l2 + 2 * n3]), `${r3} ${i4} ${s3} ${l2}`;
          }(e2), i3 && t2.attr(e2.name, i3);
        else if ("draw" !== e2.name && "animate" !== e2.name || "path" !== (s2 = n2 && n2.name) && "line" !== s2 && "circle" !== s2 && "ellipse" !== s2 && "rect" !== s2 && "polygon" !== s2 && "polyline" !== s2)
          t2.attr(e2.name, i3);
        else {
          let [e3, n3] = String(i3).split(/\s+/);
          ("indefinite" === e3 || "infinite" === e3 || /\d$/.test(e3)) && ([e3, n3] = [n3, e3]), "infinite" === n3 && (n3 = "indefinite"), t2.attr("stroke-dasharray", 10), t2.attr("pathLength", 10);
          let r3 = new gt("animate");
          r3.attr("attributeName", "stroke-dashoffset"), r3.attr("from", 10), r3.attr("to", 0), r3.attr("dur", e3), n3 && r3.attr("repeatCount", n3), t2.append(r3);
        }
        e2.name.includes("xlink:") && r2.attr("xmlns:xlink", Ie.split("=")[1]);
      }
    var s2;
    return n2 ? i2 : r2.toString();
  }
  function bt(e2) {
    return yt(e2);
  }
  const xt = ["auto", "reverse"], _t = ["deg", "rad", "grad", "turn"];
  function $t(e2) {
    let t2 = r(p(e2)), n2 = false, i2 = "", s2 = { direction: "", angle: "" };
    for (; t2.next(); ) {
      let { prev: e3, curr: r2, next: l2 } = t2.get();
      if (r2.isWord() && xt.includes(r2.value))
        s2.direction = r2.value, n2 = true;
      else if (r2.isNumber())
        s2.angle = Number(r2.value), n2 = true;
      else if (r2.isWord() && e3 && e3.isNumber() && _t.includes(r2.value))
        i2 = r2.value;
      else if (r2.isSpace() && "" !== s2.direction && "" !== s2.angle)
        break;
    }
    return n2 || (s2.direction = "auto"), function(e3, t3) {
      let { angle: n3 } = e3;
      "" === n3 && (n3 = 0);
      "rad" === t3 && (n3 /= Math.PI / 180);
      "grad" === t3 && (n3 *= 0.9);
      "turn" === t3 && (n3 *= 360);
      return Object.assign({}, e3, { angle: n3 });
    }(s2, i2);
  }
  function wt(e2, t2, n2) {
    return ["fill-rule", "fill"].includes(e2) ? t2 : n2 ? `-1 * (${t2})` : t2;
  }
  function kt(e2) {
    return e2.map((e3) => e3.value).join("");
  }
  const { cos: St, sin: jt, abs: At, atan2: Nt, PI: Et } = Math, Tt = { circle: "\n split:180;scale:.99\n ", triangle: "\n rotate:30;scale:1.1;move:0 .2\n ", pentagon: "\n split:5;rotate:54\n ", hexagon: "\n split:6;rotate:30;scale:.98\n ", octagon: "\n split:8;rotat:22.5;scale:.99\n ", star: "\n split:10;r:cos(5t);rotate:-18;scale:.99\n ", infinity: "\n split:180;scale:.99;x:cos(t)*.99 / (sin(t)^2 + 1);y:x * sin(t)\n ", heart: "\n split:180;rotate:180;a:cos(t)*13/18 - cos(2t)*5/18;b:cos(3t)/18 + cos(4t)/18;x:(.75 * sin(t)^3) * 1.2;y:(a - b + .2) * -1.1\n ", bean: "\n split:180;r:sin(t)^3 + cos(t)^3;move:-.35 .35;", bicorn: "\n split:180;x:cos(t);y:sin(t)^2 / (2 + sin(t)) - .5\n ", drop: "\n split:180;rotate:90;scale:.95;x:sin(t);y:(1 + sin(t)) * cos(t) / 1.6\n ", fish: "\n split:240;x:cos(t) - sin(t)^2 / sqrt(2) - .04;y:sin(2t)/2\n ", whale: "\n split:240;rotate:180;R:3.4 * (sin(t)^2 - .5) * cos(t);x:cos(t) * R + .75;y:sin(t) * R * 1.2\n ", windmill: "\n split:18;R:seq(.618, 1, 0);T:seq(t-.55, t, t);x:R * cos(T);y:R * sin(T)\n ", vase: "\n split:240;scale:.3;x:sin(4t) + sin(t) * 1.4;y:cos(t) + cos(t) * 4.8 + .3\n ", clover: (e2 = 3) => (4 == (e2 = v(e2, 3, 5)) && (e2 = 2), `
 split:240;r:cos(${e2}t);scale:.98
`), hypocycloid: (e2 = 3) => `
 split:240;scale:${[0.34, 0.25, 0.19][(e2 = v(e2, 3, 5)) - 3]};k:${e2};x:(k-1)*cos(t) + cos((k-1)*t);y:(k-1)*sin(t) - sin((k-1)*t)
`, bud: (e2 = 3) => `
 split:240;scale:.8;r:1 + .2 * cos(${e2 = v(e2, 3, 10)}t)
` };
  class Rt {
    constructor(e2, t2, n2) {
      this.x = e2, this.y = t2, this.extra = n2;
    }
    valueOf() {
      return this.x + " " + this.y;
    }
    toString() {
      return this.valueOf();
    }
  }
  function zt(e2, t2) {
    t2 || (t2 = (e3) => [St(e3), jt(e3)]);
    let n2, r2, i2 = e2.split || 180, s2 = e2.turn || 1, l2 = e2.frame, o2 = e2.fill || e2["fill-rule"], a2 = $t(e2.direction || e2.dir || ""), u2 = e2.unit, c2 = 2 * Et * s2 / i2, h2 = [], p2 = void 0 === e2.scale ? 1 : e2.scale, f2 = ([e3, t3, n3 = 0, r3 = 0]) => {
      if ("evenodd" == e3 || "nonzero" == e3)
        return h2.push(new Rt(e3, "", ""));
      let [i3, s3] = Ct(e3, -t3, p2), [l3, o3] = Ct(n3, -r3, p2), c3 = function(e4, t4, n4, r4, i4) {
        let s4 = 180 * Nt(t4 + r4, e4 - n4) / Et;
        "reverse" === i4.direction && (s4 -= 180);
        i4.direction || (s4 = 90);
        i4.angle && (s4 += i4.angle);
        return s4;
      }(i3, s3, l3, o3, a2);
      void 0 !== u2 && "%" !== u2 ? "none" !== u2 && (i3 += u2, s3 += u2) : (i3 = 50 * (i3 + 1) + "%", s3 = 50 * (s3 + 1) + "%"), h2.push(new Rt(i3, s3, c3));
    };
    "nonzero" != o2 && "evenodd" != o2 || f2([o2, "", ""]);
    for (let e3 = 0; e3 < i2; ++e3) {
      let r3 = t2(c2 * e3, e3);
      e3 || (n2 = r3), f2(r3);
    }
    if (void 0 !== l2) {
      f2(n2);
      let e3 = l2 / 100;
      s2 > 1 && (e3 *= 2), 0 == e3 && (e3 = 2e-3);
      for (let n3 = 0; n3 < i2; ++n3) {
        let i3 = -c2 * n3, [s3, l3, o3 = 0, a3 = 0] = t2(i3, n3), u3 = Nt(l3 + a3, s3 - o3), h3 = [s3 - e3 * St(u3), l3 - e3 * jt(u3)];
        n3 || (r2 = h3), f2(h3);
      }
      f2(r2), f2(n2);
    }
    return h2;
  }
  function Ct(e2, t2, n2) {
    let [r2, i2 = r2] = O(n2).map(Number);
    return [e2 * r2, t2 * i2];
  }
  function Mt(e2, { min: t2, max: n2 }) {
    let r2 = v(parseInt(e2.vertices || e2.points || e2.split) || 0, t2, n2), i2 = $(e2.x) ? "cos(t)" : e2.x, s2 = $(e2.y) ? "sin(t)" : e2.y, l2 = $(e2.r) ? "" : e2.r, o2 = $(e2.t) ? "" : e2.t, { unit: a2, value: u2 } = De(l2);
    return a2 && !e2[a2] && "t" !== a2 && ($(e2.unit) && (e2.unit = a2), l2 = e2.r = u2), e2.degree && (e2.rotate = e2.degree), e2.origin && (e2.move = e2.origin), e2.split = r2, zt(e2, (t3, n3) => {
      let a3 = Object.assign({}, e2, { t: o2 || t3, θ: o2 || t3, i: n3 + 1, seq: (...e3) => e3.length ? e3[n3 % e3.length] : "", range: (e3, t4 = 0) => ((e3 = Number(e3) || 0) > (t4 = Number(t4) || 0) && ([e3, t4] = [t4, e3]), e3 + At(t4 - e3) / (r2 - 1) * n3) }), u3 = at(i2, a3), c2 = at(s2, a3), h2 = 0, p2 = 0;
      if (l2) {
        let e3 = at(l2, a3);
        0 == e3 && (e3 = 1e-5), o2 && (t3 = at(o2, a3)), u3 = e3 * St(t3), c2 = e3 * jt(t3);
      }
      return e2.rotate && ([u3, c2] = function(e3, t4, n4) {
        let r3 = -Et / 180 * n4;
        return [e3 * St(r3) - t4 * jt(r3), t4 * St(r3) + e3 * jt(r3)];
      }(u3, c2, Number(e2.rotate) || 0)), e2.move && ([u3, c2, h2, p2] = function(e3, t4, n4) {
        let [r3, i3 = r3] = O(n4).map(Number);
        return [e3 + (r3 || 0), t4 - (i3 || 0), r3, i3];
      }(u3, c2, e2.move)), [u3, c2, h2, p2];
    });
  }
  function Pt(e2, t2 = 3, n2 = 3600, i2) {
    let s2 = "", [l2, ...o2] = O(e2), a2 = false;
    switch (typeof Tt[l2]) {
      case "function":
        s2 = Tt[l2](...o2), a2 = true;
        break;
      case "string":
        s2 = Tt[l2], a2 = true;
        break;
      default:
        s2 = e2;
    }
    let u2 = function(e3) {
      let t3, n3 = r(p(e3)), i3 = {}, s3 = [], l3 = false;
      for (; n3.next(); ) {
        let { prev: e4, curr: r2, next: o3 } = n3.get();
        if (r2.isSymbol(":") && !t3)
          t3 = kt(s3), s3 = [];
        else if (r2.isSymbol(";") && t3)
          i3[t3] = wt(t3, kt(s3), l3), s3 = [], t3 = null, l3 = false;
        else if (!r2.isSymbol(";")) {
          let n4 = e4 && e4.isSymbol("-"), i4 = o3 && o3.isSymbol("-"), a3 = r2.isSymbol("-");
          t3 || s3.length || !a3 || n4 || i4 || o3 && o3.isSymbol(":") ? s3.push(r2) : l3 = true;
        }
      }
      return s3.length && t3 && (i3[t3] = wt(t3, kt(s3), l3)), i3;
    }(s2);
    return "function" == typeof i2 && (u2 = i2(u2)), { rules: u2, points: Mt(u2, { min: t2, max: n2 }), preset: a2 };
  }
  function Ot(e2) {
    return w((t2, n2, ...r2) => {
      if (!r2 || !n2)
        return "";
      let i2 = S(n2()), s2 = i2;
      /\D/.test(i2) && !/\d+[x-]\d+/.test(i2) && (s2 = at(i2), 0 === s2 && (s2 = i2));
      let l2 = Math.random();
      return function(e3, t3) {
        let [n3, r3 = 1] = String(e3).split(/[x-]/), [i3, s3] = [Math.ceil(n3), Math.ceil(r3)];
        _(i3) && (i3 = 1), _(s3) && (s3 = 1), n3 = v(i3, 0, 65536), r3 = v(s3, 0, 65536);
        let l3 = n3 * r3, o2 = [], a2 = 1;
        if (/x/.test(e3))
          for (let e4 = 1; e4 <= r3; ++e4)
            for (let i4 = 1; i4 <= n3; ++i4)
              o2.push(t3(a2, i4, e4, l3, n3, r3, a2)), a2++;
        else if (/-/.test(e3))
          if (l3 = Math.abs(n3 - r3) + 1, n3 <= r3)
            for (let e4 = n3; e4 <= r3; ++e4)
              o2.push(t3(e4, e4, 1, l3, l3, 1, a2++));
          else
            for (let e4 = n3; e4 >= r3; --e4)
              o2.push(t3(e4, e4, 1, l3, l3, 1, a2++));
        else
          for (let e4 = 1; e4 <= n3; ++e4)
            o2.push(t3(e4, e4, 1, n3, n3, 1, a2++));
        return o2;
      }(s2, (...e3) => r2.map((t3) => S(t3(...e3, l2))).join(",")).join(e2);
    });
  }
  function It(e2, t2, n2) {
    return e2[t2] || (e2[t2] = new Ze(1024)), e2[t2].push(n2), n2;
  }
  function Wt(e2) {
    return -1 * e2;
  }
  function Lt(e2, t2, n2) {
    switch (e2) {
      case "+":
        return t2 + n2;
      case "-":
        return t2 - n2;
      case "*":
        return t2 * n2;
      case "/":
        return t2 / n2;
      case "%":
        return t2 % n2;
      default:
        return 0;
    }
  }
  function Dt(e2) {
    return (t2) => {
      if ($(t2) || $(e2))
        return e2;
      if (/^[\+\*\-\/%][\-\.\d\s]/.test(t2)) {
        let n2 = t2[0], { unit: r2 = "", value: i2 } = De(t2.substr(1).trim() || 0);
        return /^var/.test(e2) ? `calc((${e2} ${n2} ${i2}) * 1${r2})` : Lt(n2, e2, i2) + r2;
      }
      if (/[\+\*\-\/%]$/.test(t2)) {
        let n2 = t2.substr(-1), { unit: r2 = "", value: i2 } = De(t2.substr(0, t2.length - 1).trim() || 0);
        return /^var/.test(e2) ? `calc((${i2} ${n2} ${e2}) * 1${r2})` : Lt(n2, i2, e2) + r2;
      }
      {
        let { unit: n2 = "", value: r2 } = De(t2 || 0);
        return e2 + r2 + n2;
      }
    };
  }
  const Bt = y({ i: ({ count: e2 }) => Dt(e2), y: ({ y: e2 }) => Dt(e2), x: ({ x: e2 }) => Dt(e2), z: ({ z: e2 }) => Dt(e2), I: ({ grid: e2 }) => Dt(e2.count), Y: ({ grid: e2 }) => Dt(e2.y), X: ({ grid: e2 }) => Dt(e2.x), Z: ({ grid: e2 }) => Dt(e2.z), iI: ({ count: e2, grid: t2 }) => Dt(e2 / t2.count), id: ({ x: e2, y: t2, z: n2 }) => (r2) => k(e2, t2, n2), dx: ({ x: e2, grid: t2 }) => (n2) => (n2 = Number(n2) || 0, e2 - 0.5 - n2 - t2.x / 2), dy: ({ y: e2, grid: t2 }) => (n2) => (n2 = Number(n2) || 0, e2 - 0.5 - n2 - t2.y / 2), n({ extra: e2 }) {
    let t2 = M(e2);
    return t2 ? Dt(t2[0]) : "@n";
  }, nx({ extra: e2 }) {
    let t2 = M(e2);
    return t2 ? Dt(t2[1]) : "@nx";
  }, ny({ extra: e2 }) {
    let t2 = M(e2);
    return t2 ? Dt(t2[2]) : "@ny";
  }, N({ extra: e2 }) {
    let t2 = M(e2);
    return t2 ? Dt(t2[3]) : "@N";
  }, nN({ extra: e2 }) {
    let t2 = M(e2);
    return t2 ? Dt(t2[0] / t2[3]) : "@nN";
  }, m: Ot(","), M: Ot(" "), µ: Ot(""), p: ({ context: e2, pick: t2 }) => Ge((...n2) => {
    n2.length || (n2 = e2.last_pick_args || []);
    let r2 = t2(n2);
    return e2.last_pick_args = n2, It(e2, "last_pick", r2);
  }), P({ context: e2, pick: t2, position: n2 }) {
    let r2 = "P-counter" + n2;
    return Ge((...n3) => {
      let i2 = true;
      n3.length || (n3 = e2.last_pick_args || [], i2 = false);
      let s2 = e2.last_pick, l2 = s2 ? s2.last(1) : "";
      if (i2 && (e2[r2] || (e2[r2] = {}), l2 = e2[r2].last_pick), n3.length > 1) {
        let e3 = n3.findIndex((e4) => e4 === l2);
        -1 !== e3 && n3.splice(e3, 1);
      }
      let o2 = t2(n3);
      return e2.last_pick_args = n3, i2 && (e2[r2].last_pick = o2), It(e2, "last_pick", o2);
    });
  }, pl({ context: e2, extra: t2, position: n2 }) {
    let r2 = M(t2), i2 = "pl-counter" + n2 + (r2 ? M(r2) : "");
    return Ge((...t3) => {
      e2[i2] || (e2[i2] = 0), e2[i2] += 1;
      let n3 = t3.length, s2 = r2 && r2[6];
      x(s2) && (s2 = e2[i2]);
      let l2 = t3[(s2 - 1) % n3];
      return It(e2, "last_pick", l2);
    });
  }, pr({ context: e2, extra: t2, position: n2 }) {
    let r2 = M(t2), i2 = "pr-counter" + n2 + (r2 ? M(r2) : "");
    return Ge((...t3) => {
      e2[i2] || (e2[i2] = 0), e2[i2] += 1;
      let n3 = t3.length, s2 = r2 && r2[6];
      x(s2) && (s2 = e2[i2]);
      let l2 = t3[n3 - (s2 - 1) % n3 - 1];
      return It(e2, "last_pick", l2);
    });
  }, pd({ context: e2, extra: t2, position: n2, shuffle: r2 }) {
    let i2 = M(t2), s2 = i2 ? M(i2) : "", l2 = "pd-counter" + n2 + s2, o2 = "pd-values" + n2 + s2;
    return Ge((...t3) => {
      e2[l2] || (e2[l2] = 0), e2[l2] += 1, e2[o2] || (e2[o2] = r2(t3 || []));
      let n3 = t3.length, s3 = i2 && i2[6];
      x(s3) && (s3 = e2[l2]);
      let a2 = (s3 - 1) % n3, u2 = e2[o2][a2];
      return It(e2, "last_pick", u2);
    });
  }, lp: ({ context: e2 }) => (t2 = 1) => {
    let n2 = e2.last_pick;
    return n2 ? n2.last(t2) : "";
  }, r: ({ context: e2, rand: t2 }) => (...n2) => {
    let r2 = (n2.every(b) ? Ue : Be)(t2)(...n2);
    return It(e2, "last_rand", r2);
  }, rn({ x: e2, y: t2, context: n2, position: r2, grid: i2, extra: s2, random: l2 }) {
    let o2 = "noise-2d" + r2, a2 = o2 + "offset-x", u2 = o2 + "offset-y", [c2, h2, p2, f2, d2, m2] = M(s2) || [], g2 = c2 && f2;
    return (...r3) => {
      let { from: s3 = 0, to: c3 = s3, frequency: f3 = 1, scale: y2 = 1, octave: x2 = 1 } = Qe(r3, ["from", "to", "frequency", "scale", "octave"]);
      f3 = v(f3, 0, 1 / 0), y2 = v(y2, 0, 1 / 0), x2 = v(x2, 1, 100), 1 == r3.length && ([s3, c3] = [0, s3]), n2[o2] || (n2[o2] = new Je()), n2[a2] || (n2[a2] = l2()), n2[u2] || (n2[u2] = l2());
      let _2 = b(s3) && b(c3) ? Ue : Be, $2 = n2[o2], w2 = n2[a2], k2 = n2[u2], S2 = (g2 ? (h2 - 1) / d2 : (e2 - 1) / i2.x) + w2, j2 = (g2 ? (p2 - 1) / m2 : (t2 - 1) / i2.y) + k2;
      (d2 <= 1 || i2.x <= 1) && (S2 = 0), (m2 <= 1 || i2.y <= 1) && (j2 = 0), 0 == S2 && 0 == j2 && (S2 = w2, j2 = k2);
      let A2 = $2.noise(S2 * f3, j2 * f3, 0) * y2;
      for (let e3 = 1; e3 < x2; ++e3) {
        let t3 = 2 * e3;
        A2 += $2.noise(S2 * f3 * t3, j2 * f3 * t3, 0) * (y2 / t3);
      }
      let N2 = _2((e3, t3) => function(e4, t4, n3, r4 = 1) {
        let i3 = Math.sqrt(0.5) * r4, [s4, l3] = [-i3, i3];
        return T((e4 - s4) / (l3 - s4), t4 * r4, n3 * r4);
      }(A2, e3, t3, y2));
      return It(n2, "last_rand", N2(s3, c3));
    };
  }, lr: ({ context: e2 }) => (t2 = 1) => {
    let n2 = e2.last_rand;
    return n2 ? n2.last(t2) : "";
  }, stripe: () => (...e2) => {
    let t2, n2 = e2.map(S), r2 = n2.length, i2 = 0, s2 = [];
    if (!r2)
      return "";
    n2.forEach((e3) => {
      let [t3, n3] = O(e3);
      void 0 !== n3 ? s2.push(n3) : i2 += 1;
    });
    let l2 = s2.length ? `(100% - ${s2.join(" - ")}) / ${i2}` : `100% / ${r2}`;
    return n2.map((e3, n3) => {
      if (s2.length) {
        let [n4, r3] = O(e3);
        return t2 = (t2 ? t2 + " + " : "") + (void 0 !== r3 ? r3 : l2), `${n4} 0 calc(${t2})`;
      }
      return `${e3} 0 ${100 / r2 * (n3 + 1)}%`;
    }).join(",");
  }, calc: () => (e2, t2) => at(S(e2), t2), hex: () => (e2) => parseInt(S(e2)).toString(16), svg: w((e2, ...t2) => {
    let n2 = t2.map((e3) => S(e3())).join(",");
    if (!n2.startsWith("<")) {
      n2 = bt(V(n2));
    }
    return We(Le(n2));
  }), "svg-filter": w((e2, ...t2) => {
    let n2 = t2.map((e3) => S(e3())), r2 = n2.join(","), i2 = R("filter-");
    if (n2.every((e3) => /^[\-\d.]/.test(e3) || /^(\w+)/.test(e3) && !/[{}<>]/.test(e3))) {
      let { frequency: t3, scale: i3, octave: s2, seed: l2 = e2.seed, blur: o2, erode: a2, dilate: u2 } = Qe(n2, ["frequency", "scale", "octave", "seed", "blur", "erode", "dilate"]);
      if (r2 = "\n x:-20%;y:-20%;width:140%;height:140%;", x(u2) || (r2 += `
 feMorphology{operator:dilate;radius:${u2};}`), x(a2) || (r2 += `
 feMorphology{operator:erode;radius:${a2};}`), x(o2) || (r2 += `
 feGaussianBlur{stdDeviation:${o2};}`), !x(t3)) {
        let [e3, n3 = e3] = O(t3);
        s2 = s2 ? `numOctaves:${s2};` : "", r2 += `
 feTurbulence{type:fractalNoise;baseFrequency:${e3} ${n3};seed:${l2};${s2}}`, i3 && (r2 += `
 feDisplacementMap{in:SourceGraphic;scale:${i3};}`);
      }
    }
    if (!r2.startsWith("<")) {
      r2 = bt(V(r2, { type: "block", name: "filter" }));
    }
    return We(Le(r2).replace(/<filter([\s>])/, `<filter id="${i2}"$1`), i2);
  }), "svg-pattern": w((e2, ...t2) => We(bt(V(`
 viewBox:0 0 1 1;preserveAspectRatio:xMidYMid slice;rect{width, height:100%;fill:defs pattern{${t2.map((e3) => S(e3())).join(",")}}}`)))), "svg-polygon": w((e2, ...t2) => {
    let n2 = t2.map((e3) => S(e3())).join(","), { rules: r2, points: i2 } = Pt(n2, 3, 65536, (e3) => (delete e3.frame, e3.unit = "none", e3["stroke-width"] ?? (e3["stroke-width"] = 0.01), e3.stroke ?? (e3.stroke = "currentColor"), e3.fill ?? (e3.fill = "none"), e3)), s2 = `points:${i2};`, l2 = "";
    for (let e3 of Object.keys(r2))
      /^(stroke|fill|clip|marker|mask|animate|draw)/.test(e3) && (l2 += `${e3}:${r2[e3]};`);
    return We(bt(V(`
 viewBox:-1 -1 2 2 p ${Number(r2["stroke-width"]) / 2};polygon{${l2} ${s2}}`)));
  }), var: () => (e2) => `var(${S(e2)})`, ut: () => Dt(`var(--${ut.name})`), uw: () => Dt(`var(--${pt})`), uh: () => Dt(`var(--${ft})`), ux: () => Dt(`var(--${ct})`), uy: () => Dt(`var(--${ht})`), plot({ count: e2, context: t2, extra: n2, position: r2, grid: i2 }) {
    let s2 = "offset-points" + r2, l2 = M(n2);
    return (...n3) => {
      let r3 = n3.join(","), [o2 = e2, a2, u2, c2 = i2.count] = l2 || [];
      if (!t2[s2]) {
        let { points: e3 } = Pt(r3, 1, 65536, (e4) => (delete e4.fill, delete e4["fill-rule"], delete e4.frame, e4.points = c2, e4));
        t2[s2] = e3;
      }
      return t2[s2][o2 - 1];
    };
  }, Plot({ count: e2, context: t2, extra: n2, position: r2, grid: i2 }) {
    let s2 = "Offset-points" + r2, l2 = M(n2);
    return (...n3) => {
      let r3 = n3.join(","), [o2 = e2, a2, u2, c2 = i2.count] = l2 || [];
      if (!t2[s2]) {
        let { points: e3 } = Pt(r3, 1, 65536, (e4) => (delete e4.fill, delete e4["fill-rule"], delete e4.frame, e4.points = c2, e4.unit = e4.unit || "none", e4));
        t2[s2] = e3;
      }
      return t2[s2][o2 - 1];
    };
  }, shape: () => Xe("shape-function", (...e2) => {
    let t2 = e2.join(","), { points: n2 } = Pt(t2);
    return `polygon(${n2.join(",")})`;
  }), doodle: () => (e2) => e2, shaders: () => (e2) => e2, pattern: () => (e2) => e2, invert: () => (e2) => {
    let t2 = dt(e2);
    return t2.valid ? t2.commands.map(({ name: e3, value: t3 }) => {
      switch (e3) {
        case "v":
          return "h" + t3.join(" ");
        case "V":
          return "H" + t3.join(" ");
        case "h":
          return "v" + t3.join(" ");
        case "H":
          return "V" + t3.join(" ");
        default:
          return e3 + t3.join(" ");
      }
    }).join(" ") : e2;
  }, flipH: () => (e2) => {
    let t2 = dt(e2);
    return t2.valid ? t2.commands.map(({ name: e3, value: t3 }) => {
      switch (e3) {
        case "h":
        case "H":
          return e3 + t3.map(Wt).join(" ");
        default:
          return e3 + t3.join(" ");
      }
    }).join(" ") : e2;
  }, flipV: () => (e2) => {
    let t2 = dt(e2);
    return t2.valid ? t2.commands.map(({ name: e3, value: t3 }) => {
      switch (e3) {
        case "v":
        case "V":
          return e3 + t3.map(Wt).join(" ");
        default:
          return e3 + t3.join(" ");
      }
    }).join(" ") : e2;
  }, flip(...e2) {
    let t2 = Bt.flipH(...e2), n2 = Bt.flipV(...e2);
    return (e3) => n2(t2(e3));
  }, reverse: () => (...e2) => {
    let t2 = e2.map(S), n2 = dt(t2.join(","));
    if (n2.valid) {
      let e3 = [];
      for (let t3 = n2.commands.length - 1; t3 >= 0; --t3) {
        let { name: r2, value: i2 } = n2.commands[t3];
        e3.push(r2 + i2.join(" "));
      }
      return e3.join(" ");
    }
    return t2.reverse();
  }, cycle: () => (...e2) => {
    let t2, n2 = [];
    1 == (e2 = e2.map((e3) => "<" + e3 + ">")).length ? (t2 = " ", n2 = O(e2[0], { symbol: t2 })) : (t2 = ",", n2 = O(e2.map(S).join(t2), { symbol: t2 })), n2 = n2.map((e3) => e3.replace(/^\<|>$/g, ""));
    let r2 = n2.length - 1, i2 = [n2.join(t2)];
    for (let e3 = 0; e3 < r2; ++e3) {
      let e4 = n2.shift();
      n2.push(e4), i2.push(n2.join(t2));
    }
    return i2;
  }, mirror: () => (...e2) => {
    for (let t2 = e2.length - 1; t2 >= 0; --t2)
      e2.push(e2[t2]);
    return e2;
  }, Mirror: () => (...e2) => {
    for (let t2 = e2.length - 2; t2 >= 0; --t2)
      e2.push(e2[t2]);
    return e2;
  }, code: () => (...e2) => e2.map((e3) => String.fromCharCode(e3)), once: w(({ context: e2, extra: t2, position: n2 }, ...r2) => {
    let i2 = "once-counter" + n2;
    return x(e2[i2]) ? e2[i2] = r2.map((e3) => S(e3())).join(",") : e2[i2];
  }), raw: ({ rules: e2 }) => (t2 = "") => {
    try {
      let n2 = t2.substring(t2.indexOf(",") + 1, t2.lastIndexOf('")'));
      if (t2.startsWith("${doodle") && t2.endsWith("}")) {
        let n3 = t2.substring(2, t2.length - 1), r2 = e2.doodles;
        if (r2 && r2[n3])
          return `<css-doodle>${r2[n3].doodle}</css-doodle>`;
      }
      if (t2.startsWith('url("data:image/svg+xml;utf8'))
        return decodeURIComponent(n2);
      if (t2.startsWith('url("data:image/svg+xml;base64'))
        return atob(n2);
      if (t2.startsWith('url("data:image/png;base64'))
        return `<img src="${t2}" alt="" />`;
    } catch (e3) {
    }
    return t2;
  } }, { index: "i", col: "x", row: "y", depth: "z", rand: "r", pick: "p", pn: "pl", pnr: "pr", stripes: "stripe", strip: "stripe", patern: "pattern", flipv: "flipV", fliph: "flipH", t: "ut", filter: "svg-filter", "last-rand": "lr", "last-pick": "lp", multiple: "m", multi: "m", rep: "µ", repeat: "µ", ms: "M", s: "I", size: "I", sx: "X", "size-x": "X", "size-col": "X", "max-col": "X", sy: "Y", "size-y": "Y", "size-row": "Y", "max-row": "Y", sz: "Z", "size-z": "Z", "size-depth": "Z", Svg: "svg", "pick-by-turn": "pl", "pick-n": "pl", "pick-d": "pd", offset: "plot", Offset: "Plot", point: "plot", Point: "Plot", unicode: "code" }), Ut = { a0: [841, 1189], a1: [594, 841], a2: [420, 594], a3: [297, 420], a4: [210, 297], a5: [148, 210], a6: [105, 148], b0: [1e3, 1414], b1: [707, 1e3], b2: [500, 707], b3: [353, 500], b4: [250, 353], b5: [176, 250], b6: [125, 176], c0: [917, 1297], c1: [648, 917], c2: [458, 648], c3: [324, 458], c4: [229, 324], c5: [162, 229], d0: [764, 1064], d1: [532, 760], d2: [380, 528], d3: [264, 376], d4: [188, 260], d5: [130, 184], d6: [92, 126], letter: [216, 279], postcard: [100, 148], poster: [390, 540] }, Ft = { portrait: "p", pt: "p", p: "p", landscape: "l", ls: "l", l: "l" };
  let Xt = [];
  function qt(e2) {
    let t2 = new RegExp(`\\-?${e2}\\-?`);
    return function(e3) {
      if (!Xt.length) {
        let e4 = /* @__PURE__ */ new Set();
        if ("undefined" != typeof document)
          for (let t3 in document.head.style)
            t3.startsWith("-") || e4.add(t3.replace(/[A-Z]/g, "-$&").toLowerCase());
        e4.has("grid-gap") || e4.add("grid-gap"), Xt = Array.from(e4);
      }
      return e3 instanceof RegExp ? Xt.filter((t3) => e3.test(t3)) : Xt;
    }(t2).map((e3) => e3.replace(t2, "")).reduce((e3, t3) => (e3[t3] = t3, e3), {});
  }
  const Ht = qt("webkit"), Yt = qt("moz");
  function Gt(e2, t2) {
    return Ht[e2] ? `-webkit-${t2} ${t2}` : Yt[e2] ? `-moz-${t2} ${t2}` : t2;
  }
  const Vt = "--_cell-width", Zt = "--_cell-height", Kt = { center: "50%", left: "0%", right: "100%", top: "50%", bottom: "50%" }, Jt = { center: "50%", top: "0%", bottom: "100%", left: "50%", right: "50%" };
  var Qt = y({ size(e2, { is_special_selector: t2, grid: n2 }) {
    let [r2, i2 = r2, s2] = O(e2);
    Ut[r2] && ([r2, i2] = function(e3, t3) {
      e3 = String(e3).toLowerCase();
      let [n3, r3] = Ut[e3] || [];
      return "p" == Ft[t3] && ([r3, n3] = [n3, r3]), [r3, n3].map((e4) => e4 + "mm");
    }(r2, i2));
    let l2 = `width:${r2};height:${i2};`;
    return "auto" !== r2 && "auto" !== i2 || (s2 && (/^\(.+\)$/.test(s2) ? s2 = s2.substring(1, s2.length - 1) : /^calc/.test(s2) || (s2 = `calc(${s2})`), t2 || (l2 += `aspect-ratio:${s2};`)), t2 && (l2 += `aspect-ratio:${s2 || n2.ratio};`)), t2 || (l2 += `${Vt}:${r2};${Zt}:${i2};`), l2;
  }, place(e2, { extra: t2 }) {
    let [n2, r2 = "50%"] = O(e2);
    n2 = Kt[n2] || n2, r2 = Jt[r2] || r2;
    let i2 = `var(${Vt}, 25%)`, s2 = `var(${Zt}, 25%)`;
    return `
 position:absolute;left:${n2};top:${r2};width:${i2};height:${s2};margin-left:calc(${i2} / -2);margin-top:calc(${s2} / -2);grid-area:unset;--plot-angle:${t2 || 0};rotate:${t2 || 0}deg;`;
  }, grid(e2, t2) {
    let n2 = { clip: true };
    /no\-*clip/i.test(e2) && (n2.clip = false, e2 = e2.replace(/no\-*clip/i, ""));
    let r2 = O(e2, { symbol: ["/", "+", "^", "*", "|", "-", "~", "∆"], noSpace: true, verbose: true });
    for (let { group: e3, value: i2 } of r2)
      "+" === e3 && (n2.scale = i2), "^" === e3 && (n2.enlarge = i2), "*" === e3 && (n2.rotate = i2), "~" === e3 && (n2.translate = i2), "∆" === e3 && (n2.persp = O(i2, { symbol: " " })), "/" === e3 && (void 0 === n2.size ? n2.size = this.size(i2, t2) : n2.fill = i2), "|" !== e3 && "-" != e3 && "" != e3 || n2.grid || (n2.grid = Te(i2, t2.max_grid), "|" === e3 && (n2.flexCol = true), "-" === e3 && (n2.flexRow = true));
    return n2;
  }, gap: (e2) => e2, seed: (e2) => e2, shape: Xe("shape-property", (e2) => {
    let { points: t2, preset: n2 } = Pt(e2);
    if (!n2)
      return "";
    let r2 = "clip-path";
    return Gt(r2, `${r2}:polygon(${t2.join(",")});`);
  }), use(e2) {
    if (e2.length > 2)
      return e2;
  }, content: (e2) => e2 }, { "place-cell": "place", offset: "place", position: "place" });
  function en(e2, t2) {
    return "+" === t2 ? e2 : "-" === t2 ? -1 * e2 : e2;
  }
  function tn(e2) {
    return e2.reduce((e3, t2) => e3 + t2, 0);
  }
  function nn(e2) {
    return e2 % 2;
  }
  function rn(e2) {
    return !nn(e2);
  }
  function sn(e2) {
    let t2 = "";
    return t2 = 0 == e2 ? "$:hover" : e2 > 0 ? `$:hover ${"+*".repeat(e2)}` : `:has(+ ${"*+".repeat(Math.abs(e2 + 1))} $:hover)`, t2;
  }
  function ln(e2, t2) {
    if ("even" === e2)
      return rn(t2);
    if ("odd" === e2)
      return nn(t2);
    if ("n" == e2)
      return true;
    let { a: n2, b: i2, error: s2 } = function(e3) {
      let t3, n3, i3 = r(p(e3)), s3 = [], l2 = [];
      for (; i3.next(); ) {
        let { prev: e4, curr: r2, next: o2 } = i3.get(), a2 = r2.value;
        if (r2.isSymbol()) {
          if ("+" !== a2 && "-" !== a2) {
            n3 = "Unexpected " + r2.value;
            break;
          }
          t3 = a2;
        } else if (r2.isNumber()) {
          if ((s3.length || l2.length) && !t3) {
            n3 = "Syntax error";
            break;
          }
          if (a2 = en(Number(a2), t3), t3 = null, o2 && "n" === o2.value) {
            s3.push(a2), i3.next();
            continue;
          }
          l2.push(a2);
        } else if ("n" === a2) {
          if ((s3.length || l2.length) && !t3) {
            n3 = "Syntax error";
            break;
          }
          s3.push(en(1, t3)), t3 = null;
        } else if (!r2.isSpace()) {
          n3 = "Unexpected " + a2;
          break;
        }
      }
      return n3 ? { a: 0, b: 0, error: n3 } : { a: tn(s3), b: tn(l2) };
    }(e2);
    if (s2)
      return false;
    if (0 === n2)
      return t2 === i2;
    {
      let e3 = (t2 - i2) / n2;
      return e3 >= 0 && Number.isInteger(e3);
    }
  }
  var on, an = y({ at: ({ x: e2, y: t2 }) => (n2, r2) => e2 == n2 && t2 == r2, nth: ({ count: e2, grid: t2 }) => (...t3) => {
    for (let n2 of t3)
      if (ln(n2, e2))
        return true;
  }, y: ({ y: e2, grid: t2 }) => (...t3) => {
    for (let n2 of t3)
      if (ln(n2, e2))
        return true;
  }, x: ({ x: e2, grid: t2 }) => (...t3) => {
    for (let n2 of t3)
      if (ln(n2, e2))
        return true;
  }, even: ({ x: e2, y: t2 }) => (n2) => nn(e2 + t2), odd: ({ x: e2, y: t2 }) => (n2) => rn(e2 + t2), random: ({ random: e2, count: t2, x: n2, y: r2, grid: i2 }) => (s2 = 0.5) => /\D/.test(s2) ? e2() < at("(" + s2 + ")", { x: n2, X: i2.x, y: r2, Y: i2.y, i: t2, I: i2.count, random: e2 }) : e2() < s2, match: ({ count: e2, grid: t2, x: n2, y: r2, random: i2 }) => (s2) => !!at("(" + s2 + ")", { x: n2, X: t2.x, y: r2, Y: t2.y, i: e2, I: t2.count, random: i2 }), hover: ({ count: e2, x: t2, y: n2, grid: r2, random: i2 }) => (...e3) => {
    let i3 = [];
    e3.length || i3.push(sn(0));
    for (let s2 of e3) {
      let [e4, l2] = String(s2).split(/\s+/);
      if (e4 = Number(e4), l2 = Number(l2), Number.isNaN(l2) && !Number.isNaN(e4) && i3.push(sn(e4)), !Number.isNaN(e4) && !Number.isNaN(l2)) {
        let s3 = e4 + t2, o2 = l2 + n2;
        if (s3 >= 1 && s3 <= r2.x && o2 >= 1 && o2 <= r2.y) {
          let t3 = l2 * r2.y + e4;
          i3.push(sn(t3));
        }
      }
    }
    return !!i3.length && { selector: i3.join(",") };
  } }, { col: "x", row: "y" }), un = globalThis, cn = Math, hn = [], pn = 256, fn = 6, dn = "random", mn = cn.pow(pn, fn), gn = cn.pow(2, 52), vn = 2 * gn, yn = pn - 1;
  function bn(e2, t2, n2) {
    var r2 = [], i2 = wn($n((t2 = 1 == t2 ? { entropy: true } : t2 || {}).entropy ? [e2, kn(hn)] : null == e2 ? function() {
      try {
        var e3;
        return on && (e3 = on.randomBytes) || (e3 = new Uint8Array(pn), (un.crypto || un.msCrypto).getRandomValues(e3)), kn(e3);
      } catch (e4) {
        var t3 = un.navigator, n3 = t3 && t3.plugins;
        return [+/* @__PURE__ */ new Date(), un, n3, un.screen, kn(hn)];
      }
    }() : e2, 3), r2), s2 = new xn(r2), l2 = function() {
      for (var e3 = s2.g(fn), t3 = mn, n3 = 0; e3 < gn; )
        e3 = (e3 + n3) * pn, t3 *= pn, n3 = s2.g(1);
      for (; e3 >= vn; )
        e3 /= 2, t3 /= 2, n3 >>>= 1;
      return (e3 + n3) / t3;
    };
    return l2.int32 = function() {
      return 0 | s2.g(4);
    }, l2.quick = function() {
      return s2.g(4) / 4294967296;
    }, l2.double = l2, wn(kn(s2.S), hn), (t2.pass || n2 || function(e3, t3, n3, r3) {
      return r3 && (r3.S && _n(r3, s2), e3.state = function() {
        return _n(s2, {});
      }), n3 ? (cn[dn] = e3, t3) : e3;
    })(l2, i2, "global" in t2 ? t2.global : this == cn, t2.state);
  }
  function xn(e2) {
    var t2, n2 = e2.length, r2 = this, i2 = 0, s2 = r2.i = r2.j = 0, l2 = r2.S = [];
    for (n2 || (e2 = [n2++]); i2 < pn; )
      l2[i2] = i2++;
    for (i2 = 0; i2 < pn; i2++)
      l2[i2] = l2[s2 = yn & s2 + e2[i2 % n2] + (t2 = l2[i2])], l2[s2] = t2;
    (r2.g = function(e3) {
      for (var t3, n3 = 0, i3 = r2.i, s3 = r2.j, l3 = r2.S; e3--; )
        t3 = l3[i3 = yn & i3 + 1], n3 = n3 * pn + l3[yn & (l3[i3] = l3[s3 = yn & s3 + t3]) + (l3[s3] = t3)];
      return r2.i = i3, r2.j = s3, n3;
    })(pn);
  }
  function _n(e2, t2) {
    return t2.i = e2.i, t2.j = e2.j, t2.S = e2.S.slice(), t2;
  }
  function $n(e2, t2) {
    var n2, r2 = [], i2 = typeof e2;
    if (t2 && "object" == i2)
      for (n2 in e2)
        try {
          r2.push($n(e2[n2], t2 - 1));
        } catch (e3) {
        }
    return r2.length ? r2 : "string" == i2 ? e2 : e2 + "\0";
  }
  function wn(e2, t2) {
    for (var n2, r2 = e2 + "", i2 = 0; i2 < r2.length; )
      t2[yn & i2] = yn & (n2 ^= 19 * t2[yn & i2]) + r2.charCodeAt(i2++);
    return kn(t2);
  }
  function kn(e2) {
    return String.fromCharCode.apply(0, e2);
  }
  function Sn(e2) {
    return /^\:(host|doodle)/.test(e2);
  }
  function jn(e2) {
    return /^\:(container|parent)/.test(e2);
  }
  function An(e2) {
    return Sn(e2) || jn(e2);
  }
  wn(cn.random(), hn);
  const Nn = {};
  for (let e2 of Object.getOwnPropertyNames(Math))
    Nn[e2] = () => (...t2) => "number" == typeof Math[e2] ? Math[e2] : (t2 = t2.map((e3) => at(S(e3))), Math[e2](...t2));
  class En {
    constructor(e2) {
      this.tokens = e2, this.rules = {}, this.props = {}, this.keyframes = {}, this.grid = null, this.seed = null, this.is_grid_set = false, this.is_gap_set = false, this.coords = [], this.doodles = {}, this.pattern = {}, this.shaders = {}, this.vars = {}, this.uniforms = {}, this.content = {}, this.reset();
    }
    reset() {
      this.styles = { host: "", container: "", cells: "", keyframes: "" }, this.coords = [], this.doodles = {}, this.pattern = {}, this.shaders = {}, this.content = {};
      for (let e2 in this.rules)
        e2.startsWith("#c") && delete this.rules[e2];
    }
    add_rule(e2, t2) {
      let n2 = this.rules[e2];
      n2 || (n2 = this.rules[e2] = []), n2.push.apply(n2, z(t2));
    }
    pick_func(e2) {
      return e2.startsWith("$") && (e2 = "calc"), Bt[e2] || Nn[e2];
    }
    apply_func(e2, t2, n2, r2, i2 = {}) {
      let s2 = e2(...z(t2)), l2 = [];
      if (n2.forEach((e3) => {
        let t3 = typeof e3.value;
        if (e3.cluster || "number" !== t3 && "string" !== t3) {
          if ("function" == typeof e3)
            l2.push(e3);
          else if (!x(e3.value)) {
            let t4 = S(e3.value);
            l2.push(t4);
          }
        } else
          l2.push(...O(e3.value, { noSpace: true }));
      }), l2 = z(l2.filter((e3) => !x(e3) && String(e3).trim().length)), "function" == typeof s2) {
        if (r2.startsWith("$")) {
          let e3 = Object.assign({}, this.vars.host, this.vars.container, this.vars[t2.count], i2), n3 = {}, o2 = "";
          for (let [t3, r3] of Object.entries(e3))
            n3[t3.substr(2)] = r3;
          return r2.length > 1 && (o2 = r2.split("$")[1] ?? ""), s2(l2, n3) + o2;
        }
        return s2(...l2);
      }
      return s2;
    }
    compose_aname(...e2) {
      return e2.join("-");
    }
    compose_selector({ x: e2, y: t2, z: n2 }, r2 = "") {
      return `#${k(e2, t2, n2)}${r2}`;
    }
    is_composable(e2) {
      return ["doodle", "shaders", "pattern"].includes(e2);
    }
    read_var(e2, t2, n2) {
      let r2 = t2.count, i2 = Object.assign({}, this.vars.host, this.vars.container, this.vars[r2], n2);
      if (void 0 !== i2[e2]) {
        let t3 = String(i2[e2]).trim();
        if ("(" == t3[0]) {
          ")" === t3[t3.length - 1] && (t3 = t3.substring(1, t3.length - 1));
        }
        return t3.replace(/;+$/g, "");
      }
      return e2;
    }
    compose_argument(e2, t2, n2 = [], r2, i2) {
      t2.extra || (t2.extra = []), t2.extra.push(n2);
      let s2 = e2.map((e3) => {
        if ("text" === e3.type)
          return /^\-\-\w/.test(e3.value) ? r2 && "@var" === r2.name ? e3.value : this.read_var(e3.value, t2, i2) : e3.value;
        if ("func" === e3.type) {
          let r3 = e3.name.substr(1), s3 = this.pick_func(r3);
          if ("function" == typeof s3) {
            if (this.check_uniforms(r3), this.is_composable(r3)) {
              let n3, i3 = S((e3.arguments[0] || [])[0]);
              if ("doodle" === r3 && /^\d/.test(i3) && (n3 = i3, i3 = S((e3.arguments[1] || [])[0])), !x(i3))
                switch (r3) {
                  case "doodle":
                    return this.compose_doodle(this.inject_variables(i3, t2.count), n3);
                  case "shaders":
                    return this.compose_shaders(i3, t2);
                  case "pattern":
                    return this.compose_pattern(i3, t2);
                }
            }
            t2.position = e3.position;
            let l2 = e3.arguments.map((r4) => s3.lazy ? (...n3) => this.compose_argument(r4, t2, n3, e3, i2) : this.compose_argument(r4, t2, n2, e3, i2));
            return this.apply_func(s3, t2, l2, r3, i2);
          }
          return e3.name;
        }
      });
      return t2.extra.pop(), { cluster: e2.cluster, value: s2.length >= 2 ? { value: s2.join("") } : s2[0] };
    }
    compose_doodle(e2, t2) {
      let n2 = R("doodle");
      return this.doodles[n2] = { doodle: e2, arg: t2 }, "${" + n2 + "}";
    }
    compose_shaders(e2, { x: t2, y: n2, z: r2 }) {
      let i2 = R("shader");
      return this.shaders[i2] = { shader: e2, id: "--" + i2, cell: k(t2, n2, r2) }, "${" + i2 + "}";
    }
    compose_pattern(e2, { x: t2, y: n2, z: r2 }) {
      let i2 = R("pattern");
      return this.pattern[i2] = { code: e2, id: "--" + i2, cell: k(t2, n2, r2) }, "${" + i2 + "}";
    }
    check_uniforms(e2) {
      switch (e2) {
        case "ut":
        case "t":
          this.uniforms.time = true;
          break;
        case "ux":
          this.uniforms.mousex = true;
          break;
        case "uy":
          this.uniforms.mousey = true;
          break;
        case "uw":
          this.uniforms.width = true;
          break;
        case "uh":
          this.uniforms.height = true;
      }
    }
    inject_variables(e2, t2) {
      let n2 = Object.assign({}, this.vars.host, this.vars.container, this.vars[t2]), r2 = [];
      for (let [e3, t3] of Object.entries(n2))
        r2.push(`${e3}:${t3};`);
      return r2 = r2.join(""), r2.length ? `:doodle{${r2}}` + e2 : e2;
    }
    compose_variables(e2, t2, n2 = {}) {
      for (let [r2, i2] of Object.entries(e2))
        n2[r2] = this.get_composed_value(i2, t2, n2).value;
      return n2;
    }
    compose_value(e2, t2, n2 = {}) {
      if (!Array.isArray(e2))
        return { value: "", extra: "" };
      let r2 = "", i2 = e2.reduce((e3, i3) => {
        switch (i3.type) {
          case "text":
            e3 += i3.value;
            break;
          case "func": {
            let s2 = i3.name.substr(1), l2 = this.pick_func(s2);
            if ("function" == typeof l2)
              if (this.check_uniforms(s2), this.is_composable(s2)) {
                let n3, r3 = S((i3.arguments[0] || [])[0]);
                if ("doodle" === s2 && /^\d/.test(r3) && (n3 = r3, r3 = S((i3.arguments[1] || [])[0])), !x(r3))
                  switch (s2) {
                    case "doodle":
                      e3 += this.compose_doodle(this.inject_variables(r3, t2.count), n3);
                      break;
                    case "shaders":
                      e3 += this.compose_shaders(r3, t2);
                      break;
                    case "pattern":
                      e3 += this.compose_pattern(r3, t2);
                  }
              } else {
                t2.position = i3.position, i3.variables && this.compose_variables(i3.variables, t2, n2);
                let o2 = i3.arguments.map((e4) => l2.lazy ? (...r3) => this.compose_argument(e4, t2, r3, i3, n2) : this.compose_argument(e4, t2, [], i3, n2)), a2 = this.apply_func(l2, t2, o2, s2, n2);
                x(a2) || (e3 += a2, a2.extra && (r2 = a2.extra));
              }
            else
              e3 += i3.name;
          }
        }
        return e3;
      }, "");
      return { value: i2, extra: r2 };
    }
    get_composed_value(e2, t2, n2) {
      let r2, i2 = [];
      return Array.isArray(e2) && (i2 = e2.reduce((e3, i3) => {
        let s2 = this.compose_value(i3, t2, n2 || {});
        return s2 && (s2.value && e3.push(s2.value), s2.extra && (r2 = s2.extra)), e3;
      }, [])), { extra: r2, group: i2, value: i2.join(",") };
    }
    add_grid_style({ fill: e2, clip: t2, rotate: n2, scale: r2, translate: i2, enlarge: s2, skew: l2, persp: o2, flexRow: a2, flexCol: u2 }) {
      if (e2 && this.add_rule(":host", `background-color:${e2};`), t2 || this.add_rule(":host", "contain:none;"), n2 && this.add_rule(":container", `rotate:${n2};`), r2 && this.add_rule(":container", `scale:${r2};`), i2 && this.add_rule(":container", `translate:${i2};`), o2) {
        let [e3, ...t3] = o2;
        this.add_rule(":container", `perspective:${e3};`), t3.length && this.add_rule(":container", `perspective-origin:${t3.join(" ")};`);
      }
      s2 && this.add_rule(":container", `
 width:calc(${s2} * 100%);height:calc(${s2} * 100%);left:50%;top:50%;transform-origin:0 0;transform:translate(-50%, -50%);`), a2 && (this.add_rule(":container", "display:flex;"), this.add_rule("cell", "flex:1;")), u2 && (this.add_rule(":container", "display:flex;flex-direction:column;"), this.add_rule("cell", "flex:1;"));
    }
    compose_rule(e2, t2, n2) {
      let r2 = Object.assign({}, t2), i2 = e2.property;
      if ("@seed" === i2)
        return "";
      let s2 = this.get_composed_value(e2.value, r2), l2 = s2.extra, o2 = s2.value;
      if (/^animation(\-name)?$/.test(i2)) {
        if (this.props.has_animation = true, Sn(n2)) {
          let e3 = ut[i2];
          e3 && o2 && (o2 = e3 + "," + o2);
        }
        if (r2.count > 1) {
          let { count: e3 } = r2;
          switch (i2) {
            case "animation-name":
              o2 = s2.group.map((t3) => this.compose_aname(t3, e3)).join(",");
              break;
            case "animation":
              o2 = s2.group.map((t3) => {
                let n3 = (t3 || "").split(/\s+/);
                return n3[0] = this.compose_aname(n3[0], e3), n3.join(" ");
              }).join(",");
          }
        }
      }
      "content" === i2 && (/["']|^none\s?$|^(var|counter|counters|attr|url)\(/.test(o2) || (o2 = `'${o2}'`)), "transition" === i2 && (this.props.has_transition = true);
      let a2 = `${i2}:${o2};`;
      if (a2 = Gt(i2, a2), "width" !== i2 && "height" !== i2 || An(n2) || (a2 += `--_cell-${i2}:${o2};`), /^(background|background\-image)$/.test(i2) && /\$\{(shader|pattern)/.test(o2) && (a2 += "background-size:100% 100%;"), /^\-\-/.test(i2) && this.compose_vars(t2, n2, i2, o2), /^@/.test(i2) && Qt[i2.substr(1)]) {
        let t3 = i2.substr(1), s3 = Qt[t3](o2, { is_special_selector: An(n2), grid: r2.grid, max_grid: r2.max_grid, extra: l2 });
        switch (t3) {
          case "grid":
            Sn(n2) ? (a2 = s3.size || "", this.add_grid_style(s3)) : (a2 = "", this.is_grid_set || (s3 = Qt[t3](o2, { is_special_selector: true, grid: r2.grid, max_grid: r2.max_grid }), this.add_rule(":host", s3.size || ""), this.add_grid_style(s3))), this.grid = r2.grid, this.is_grid_set = true;
            break;
          case "gap":
            a2 = "", this.is_gap_set || (this.add_rule(":container", `gap:${s3};`), this.is_gap_set = true);
            break;
          case "content": {
            a2 = "";
            let e3 = this.compose_selector(r2);
            void 0 === s3 || /\:before|\:after/.test(n2) || jn(n2) || (this.content[e3] = function(e4) {
              if (e4.startsWith('"') && e4.endsWith('"') || e4.startsWith("'") && e4.endsWith("'"))
                return e4.substring(1, e4.length - 1);
              return e4;
            }(String(s3))), this.content[e3] = Bt.raw({ rules: { doodles: this.doodles } })(this.content[e3] || "");
          }
          case "seed":
            a2 = "";
            break;
          case "place-cell":
          case "place":
          case "position":
          case "offset":
            Sn(n2) || (a2 = s3);
            break;
          case "use":
            e2.value.length && this.compose(r2, e2.value), a2 = "";
            break;
          default:
            a2 = s3;
        }
      }
      return /^grid/.test(i2) && Sn(n2) && (this.add_rule(":container", `${i2}:${o2};`), a2 = ""), a2;
    }
    get_raw_value(e2) {
      let t2 = e2.raw();
      x(t2) && (t2 = "");
      let [n2, ...r2] = t2.split(e2.property);
      return r2 = r2.join(e2.property).replace(/^\s*:\s*/, "").replace(/[;}<]$/, "").trim().replace(/[;}<]$/, ""), r2;
    }
    compose_vars(e2, t2, n2, r2) {
      let i2 = e2.count;
      jn(t2) && (i2 = "container"), Sn(t2) && (i2 = "host"), this.vars[i2] || (this.vars[i2] = {}), this.vars[i2][n2] = r2;
    }
    pre_compose_rule(e2, t2, n2) {
      let r2 = Object.assign({}, t2), i2 = e2.property, s2 = Object.assign({}, this.vars.host, this.vars.container, this.vars[r2.count]);
      if (/^\-\-/.test(i2)) {
        let l2 = this.get_composed_value(e2.value, r2, s2).value;
        this.compose_vars(t2, n2, i2, l2);
      }
      switch (i2) {
        case "@grid": {
          let n3 = this.get_composed_value(e2.value, r2, s2).value, l2 = i2.substr(1), o2 = Qt[l2](n3, { max_grid: t2.max_grid });
          this.grid = o2.grid;
          break;
        }
        case "@use":
          e2.value.length && this.pre_compose(r2, e2.value);
      }
    }
    pre_compose(e2, t2) {
      x(this.seed) && ((t2 || this.tokens).forEach((e3) => {
        if ("rule" === e3.type && "@seed" === e3.property && (this.seed = this.get_raw_value(e3)), "pseudo" === e3.type && Sn(e3.selector))
          for (let t3 of z(e3.styles))
            "rule" === t3.type && "@seed" === t3.property && (this.seed = this.get_raw_value(t3));
      }), x(this.seed) || e2.update_random(this.seed)), (t2 || this.tokens).forEach((t3) => {
        switch (t3.type) {
          case "rule":
            this.pre_compose_rule(t3, e2);
            break;
          case "pseudo":
            Sn(t3.selector) && (t3.styles || []).forEach((t4) => {
              this.pre_compose_rule(t4, e2, t4.selector);
            });
        }
      });
    }
    compose(e2, t2, n2) {
      this.coords.push(e2), (t2 || this.tokens).forEach((t3, r2) => {
        if (t3.skip)
          return false;
        if (n2 && this.grid)
          return false;
        switch (t3.type) {
          case "rule":
            this.add_rule(this.compose_selector(e2), this.compose_rule(t3, e2));
            break;
          case "pseudo": {
            t3.selector.startsWith(":doodle") && (t3.selector = t3.selector.replace(/^\:+doodle/, ":host"));
            let n3 = An(t3.selector);
            n3 && (t3.skip = true), O(t3.selector).forEach((r3) => {
              let i2 = t3.styles.map((t4) => this.compose_rule(t4, e2, r3)), s2 = n3 ? r3 : this.compose_selector(e2, r3);
              this.add_rule(s2, i2);
            });
            break;
          }
          case "cond": {
            let n3 = t3.name.substr(1), r3 = an[n3];
            if (r3) {
              let i2 = t3.arguments.map((t4) => this.compose_argument(t4, e2)), s2 = this.apply_func(r3, e2, i2, n3);
              if (Array.isArray(t3.addition))
                for (let e3 of t3.addition)
                  "not" === e3 && (s2 = !s2);
              s2 && (s2.selector ? t3.styles.forEach((t4) => {
                "rule" === t4.type && this.add_rule(s2.selector.replaceAll("$", this.compose_selector(e2)), this.compose_rule(t4, e2)), "pseudo" === t4.type && t4.selector.split(",").forEach((n4) => {
                  let r4 = t4.styles.map((t5) => this.compose_rule(t5, e2, n4));
                  this.add_rule((s2.selector + n4).replaceAll("$", this.compose_selector(e2)), r4);
                });
              }) : this.compose(e2, t3.styles));
            }
            break;
          }
          case "keyframes":
            this.keyframes[t3.name] || (this.keyframes[t3.name] = (e3) => `
 ${C(t3.steps.map((t4) => `
 ${this.get_composed_value(t4.name, e3).value}{${C(t4.styles.map((t5) => this.compose_rule(t5, e3)))}}`))}`);
        }
      });
    }
    output() {
      for (let [e3, t3] of Object.entries(this.rules))
        if (jn(e3))
          this.styles.container += `grid{${C(t3)}}`;
        else {
          let n3 = Sn(e3) ? "host" : "cells", r3 = C(t3).trim();
          if (r3.length) {
            let t4 = "host" === n3 ? `${e3},.host` : e3;
            this.styles[n3] += `${t4}{${r3}}`;
          }
        }
      this.uniforms.time && (this.styles.container += `
:host,.host{animation:${ut.animation};}`, this.styles.keyframes += `
 @keyframes ${ut["animation-name"]}{from{--${ut.name}:0} to{--${ut.name}:${ut["animation-duration"] / 10}}}`), this.coords.forEach((e3, t3) => {
        for (let [n3, r3] of Object.entries(this.keyframes)) {
          let i3 = this.compose_aname(n3, e3.count);
          this.styles.keyframes += `
 ${0 === t3 ? `@keyframes ${n3}{${r3(e3)}}` : ""} @keyframes ${i3}{${r3(e3)}}`;
        }
      });
      let { keyframes: e2, host: t2, container: n2, cells: r2 } = this.styles, i2 = e2 + t2 + n2;
      return { props: this.props, styles: { main: i2, cells: r2, all: i2 + r2 }, grid: this.grid, seed: this.seed, random: this.random, doodles: this.doodles, shaders: this.shaders, pattern: this.pattern, uniforms: this.uniforms, content: this.content };
    }
  }
  function Tn(e2, t2, n2, r2, i2) {
    let s2 = new En(e2), l2 = i2 || bn(String(n2)), o2 = {};
    function a2(e3 = 0, t3) {
      return 1 == arguments.length && ([e3, t3] = [0, e3]), T(l2(), e3, t3);
    }
    function u2(...e3) {
      let t3 = e3.reduce((e4, t4) => e4.concat(t4), []);
      return t3[~~(l2() * t3.length)];
    }
    function c2(e3) {
      let t3 = [...e3], n3 = e3.length;
      for (; n3; ) {
        let e4 = ~~(l2() * n3--), r3 = t3[n3];
        t3[n3] = t3[e4], t3[e4] = r3;
      }
      return t3;
    }
    s2.pre_compose({ x: 1, y: 1, z: 1, count: 1, context: {}, grid: { x: 1, y: 1, z: 1, count: 1 }, random: l2, rand: a2, pick: u2, shuffle: c2, max_grid: r2, update_random: function(e3) {
      l2 = bn(String(e3));
    }, seed_value: n2, rules: s2 });
    let { grid: h2, seed: p2 } = s2.output();
    if (h2 && (t2 = h2), p2 ? (p2 = String(p2), l2 = bn(p2)) : p2 = n2, x(p2) && (p2 = Date.now(), l2 = bn(p2)), p2 = String(p2), s2.seed = p2, s2.random = l2, s2.reset(), 1 == t2.z)
      for (let e3 = 1, n3 = 0; e3 <= t2.y; ++e3)
        for (let i3 = 1; i3 <= t2.x; ++i3)
          s2.compose({ x: i3, y: e3, z: 1, count: ++n3, grid: t2, context: o2, rand: a2, pick: u2, shuffle: c2, random: l2, seed: p2, max_grid: r2, rules: s2 });
    else
      for (let e3 = 1, n3 = 0; e3 <= t2.z; ++e3)
        s2.compose({ x: 1, y: 1, z: e3, count: ++n3, grid: t2, context: o2, rand: a2, pick: u2, shuffle: c2, random: l2, seed: p2, max_grid: r2, rules: s2 });
    return s2.output();
  }
  function Rn(e2, t2, n2) {
    let r2 = e2.createShader(t2);
    return e2.shaderSource(r2, n2), e2.compileShader(r2), r2;
  }
  function zn(e2, t2) {
    return e2.includes(t2) ? e2 : t2 + "\n" + e2;
  }
  function Cn(e2, t2) {
    let n2 = Fe.get(e2);
    if (n2)
      return Promise.resolve(n2);
    let r2 = document.createElement("canvas"), i2 = devicePixelRatio || 1, s2 = r2.width = e2.width * i2, l2 = r2.height = e2.height * i2, o2 = [], a2 = r2.getContext("webgl2", { preserveDrawingBuffer: true });
    if (!a2)
      return Promise.resolve("");
    let u2 = zn(e2.fragment || "", "uniform vec2 u_resolution;");
    u2 = zn(u2, "uniform float u_time;"), u2 = zn(u2, "uniform float u_timeDelta;"), u2 = zn(u2, "uniform int u_frameIndex;"), u2 = zn(u2, "uniform vec2 u_seed;"), e2.textures.forEach((e3) => {
      let t3 = `uniform sampler2D ${e3.name};`;
      u2 = zn(u2, t3);
    });
    /(^|[^\w\_])void\s+mainImage\(\s*out\s+vec4\s+fragColor,\s*in\s+vec2\s+fragCoord\s*\)/gm.test(u2) && (u2 = `
#define iResolution vec3(u_resolution, 0)
#define iTime u_time
#define iTimeDelta u_timeDelta
#define iFrame u_frameIndex

${e2.textures.map((e3, t3) => `#define iChannel${t3} ${e3.name}`).join("\n")}
${u2}
void main(){mainImage(FragColor, gl_FragCoord.xy);}`);
    let c2 = function(e3, t3, n3) {
      let r3 = Rn(e3, e3.VERTEX_SHADER, t3), i3 = Rn(e3, e3.FRAGMENT_SHADER, n3), s3 = e3.createProgram();
      return e3.attachShader(s3, r3), e3.attachShader(s3, i3), e3.linkProgram(s3), e3.getProgramParameter(s3, e3.LINK_STATUS) || (console.warn("Link failed:" + e3.getProgramInfoLog(s3)), console.warn("vs info-log:" + e3.getShaderInfoLog(r3)), console.warn("fs info-log:" + e3.getShaderInfoLog(i3))), s3;
    }(a2, e2.vertex || "#version 300 es\n in vec4 position;void main(){gl_Position = position;}", "#version 300 es\n precision highp float;out vec4 FragColor;" + u2), h2 = a2.getAttribLocation(c2, "position"), p2 = a2.createBuffer();
    a2.bindBuffer(a2.ARRAY_BUFFER, p2);
    a2.bufferData(a2.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, 1, 1, -1, 1, 1, -1]), a2.STATIC_DRAW), a2.enableVertexAttribArray(h2), a2.vertexAttribPointer(h2, 2, a2.FLOAT, false, 0, 0), a2.viewport(0, 0, a2.drawingBufferWidth, a2.drawingBufferHeight), a2.clearColor(0, 0, 0, 0), a2.clear(a2.COLOR_BUFFER_BIT), a2.useProgram(c2);
    const f2 = (e3) => a2.getUniformLocation(c2, e3), d2 = f2("u_resolution");
    a2.uniform2fv(d2, [s2, l2]), e2.textures.forEach((e3, t3) => {
      o2.push(function(e4, t4, n3) {
        const r3 = e4.createTexture();
        return e4.activeTexture(e4["TEXTURE" + n3]), e4.pixelStorei(e4.UNPACK_FLIP_Y_WEBGL, true), e4.bindTexture(e4.TEXTURE_2D, r3), e4.texImage2D(e4.TEXTURE_2D, 0, e4.RGBA, e4.RGBA, e4.UNSIGNED_BYTE, t4), e4.texParameteri(e4.TEXTURE_2D, e4.TEXTURE_WRAP_S, e4.REPEAT), e4.texParameteri(e4.TEXTURE_2D, e4.TEXTURE_WRAP_T, e4.REPEAT), e4.texParameteri(e4.TEXTURE_2D, e4.TEXTURE_MIN_FILTER, e4.LINEAR), e4.texParameteri(e4.TEXTURE_2D, e4.TEXTURE_MAG_FILTER, e4.LINEAR), r3;
      }(a2, e3.value, t3)), a2.uniform1i(a2.getUniformLocation(c2, e3.name), t3);
    });
    const m2 = f2("u_seed");
    m2 && a2.uniform2f(m2, E(t2) / 1e16, Math.random());
    const g2 = f2("u_time"), v2 = f2("u_frameIndex"), y2 = f2("u_timeDelta");
    if (g2 || y2 || v2) {
      let t3 = 0, n3 = 0;
      return Promise.resolve(Fe.set(e2, (s3, l3, u3, c3) => (a2.clear(a2.COLOR_BUFFER_BIT), e2.width === l3 && e2.height === u3 || (c3.forEach((e3, t4) => {
        a2.bindTexture(a2.TEXTURE_2D, o2[t4]), a2.texImage2D(a2.TEXTURE_2D, 0, a2.RGBA, a2.RGBA, a2.UNSIGNED_BYTE, e3.value);
      }), e2.width = l3, e2.height = u3, r2.width = l3 * i2, r2.height = u3 * i2, a2.viewport(0, 0, r2.width, r2.height), a2.uniform2fv(d2, [r2.width, r2.height])), g2 && a2.uniform1f(g2, s3 / 1e3), v2 && a2.uniform1i(v2, t3++), y2 && (a2.uniform1f(y2, (n3 - s3) / 1e3), n3 = s3), a2.drawArrays(a2.TRIANGLES, 0, 6), r2.toDataURL())));
    }
    return a2.drawArrays(a2.TRIANGLES, 0, 6), Promise.resolve(Fe.set(e2, r2.toDataURL()));
  }
  function Mn(e2, t2) {
    let n2 = [];
    for (; e2.next(); ) {
      let { curr: t3, next: r2 } = e2.get(), i2 = !r2 || t3.isSymbol(";") || r2.isSymbol("}");
      if (n2.push(t3), i2)
        break;
    }
    return n2.length && (t2.value = On(n2)), t2;
  }
  function Pn(e2, t2) {
    let n2 = [], r2 = [], i2 = t2 && t2.type || "", s2 = [];
    for (; e2.next(); ) {
      let { prev: l2, curr: o2, next: a2 } = e2.get(), u2 = !a2 || o2.isSymbol("}");
      if ("block" === i2 && u2) {
        a2 || !n2.length || o2.isSymbol("}") || (n2[n2.length - 1].value += ";" + o2.value), t2.value = n2;
        break;
      }
      if (o2.isSymbol("{") && r2.length && !s2.length) {
        let t3 = In(r2);
        if (!t3.length)
          continue;
        let i3 = Pn(e2, { type: "block", name: "unkown", value: [] });
        t3.forEach((e3) => {
          let t4 = Object.assign({}, i3, { name: e3.name, args: e3.args });
          n2.push(t4);
        }), r2 = [];
      } else if (o2.isSymbol(":") && r2.length && !s2.length) {
        let s3 = On(r2);
        n2.push(Mn(e2, { type: "statement", name: s3, value: "" })), "block" == i2 && (t2.value = n2), r2 = [];
      } else
        o2.isSymbol(";") ? n2.length && r2.length && (n2[n2.length - 1].value += ";" + On(r2), r2 = []) : (o2.isSymbol("(") && s2.push(o2), o2.isSymbol(")") && s2.pop(), r2.push(o2));
    }
    return n2.length && "block" == i2 && (t2.value = n2), i2 ? t2 : n2;
  }
  function On(e2) {
    return e2.filter((t2, n2) => !t2.isSymbol(";") || n2 !== e2.length - 1).map((e3) => e3.value).join("");
  }
  function In(e2) {
    let t2 = r(e2), n2 = [], i2 = "", s2 = [], l2 = [], o2 = [];
    for (; t2.next(); ) {
      let { curr: e3, next: r2 } = t2.get();
      !i2.length && e3.isWord() ? i2 = e3.value : e3.isSymbol("(") ? (o2.length && l2.push(e3.value), o2.push(e3)) : e3.isSymbol(")") ? (o2.pop(), o2.length ? l2.push(e3.value) : l2.length && (s2.push(l2.join("")), l2 = [])) : e3.isSymbol(",") ? o2.length ? (s2.push(l2.join("")), l2 = []) : (l2.length && (s2.push(l2.join("")), l2 = []), i2 && (n2.push({ name: i2, args: s2 }), i2 = "", s2 = [], l2 = [])) : l2.push(e3.value);
    }
    return i2 && n2.push({ name: i2, args: s2 }), n2.filter((e3, t3, n3) => n3.findIndex((t4) => t4.name === e3.name && e3.args.join("") == t4.args.join("")) === t3);
  }
  function Wn(e2) {
    return Pn(r(p(e2)));
  }
  function Ln(e2, t2) {
    if ("fill" === e2.name) {
      let { r: n2, g: r2, b: i2, a: s2 } = t2.get_rgba_color(e2.value);
      return { type: "statement", value: `
color = vec4(${Dn(n2 / 255)}, ${Dn(r2 / 255)}, ${Dn(i2 / 255)}, ${Dn(s2)});` };
    }
    return "grid" == e2.name ? { type: "grid", value: e2.value } : { type: "statement", value: "" };
  }
  function Dn(e2) {
    return String(e2).includes(".") ? e2 : e2 + ".0";
  }
  function Bn(e2, t2) {
    let n2 = Wn(e2), r2 = [], i2 = { x: 1, y: 1 };
    return n2.forEach((e3) => {
      if ("statement" === e3.type) {
        let n3 = Ln(e3, t2);
        "statement" == n3.type && r2.push(n3.value), "grid" === n3.type && (i2 = Te(n3.value, 1 / 0));
      } else
        "block" === e3.type && r2.push(function(e4, t3) {
          if ("match" === e4.name) {
            let n3 = e4.args[0], r3 = [];
            return e4.value.forEach((e5) => {
              let n4 = Ln(e5, t3);
              "statement" == n4.type && r3.push(n4.value);
            }), `
 if (${n3}){${r3.join("")}}`;
          }
          return "";
        }(e3, t2));
    }), function(e3, { x: t3, y: n3 }) {
      return `
 vec3 mapping(vec2 uv, vec2 grid){vec2 _grid = 1.0/grid;float x = ceil(uv.x/_grid.x);float y = ceil(grid.y - uv.y/_grid.y);float i = x + (y - 1.0) * y;return vec3(x, y, i);} vec4 getColor(float x, float y, float i, float I, float X, float Y, float t){vec4 color = vec4(0, 0, 0, 0);${e3} return color;} void main(){vec2 uv = gl_FragCoord.xy/u_resolution.xy;vec2 v = vec2(${t3}, ${n3});vec3 p = mapping(uv, v);FragColor = getColor(p.x, p.y, p.z, v.x * v.y, v.x, v.y, u_time);}`;
    }(r2.join(""), i2);
  }
  function Un(e2) {
    if ("undefined" == typeof getComputedStyle)
      return "";
    let t2 = {};
    if (e2.computedStyleMap)
      for (let [n2, r2] of e2.computedStyleMap())
        n2.startsWith("--") && (t2[n2] = r2[0][0]);
    else {
      let n2 = getComputedStyle(e2);
      for (let e3 of n2)
        e3.startsWith("--") && (t2[e3] = n2.getPropertyValue(e3));
    }
    return function(e3) {
      let t3 = [];
      for (let [n2, r2] of Object.entries(e3))
        t3.push(n2 + ":" + r2);
      return t3.join(";");
    }(t2);
  }
  const Fn = 1e3 / 60;
  if ("undefined" != typeof customElements) {
    class e2 extends HTMLElement {
      constructor() {
        super(), this.doodle = this.attachShadow({ mode: "open" }), this.animations = [], this.extra = { get_variable: (e3) => function(e4, t2) {
          return "undefined" == typeof getComputedStyle ? "" : getComputedStyle(e4).getPropertyValue(t2).trim().replace(/^\(|\)$/g, "");
        }(this, e3), get_rgba_color: (e3) => function(e4, t2) {
          let n2 = e4.querySelector("style");
          return n2 ? (n2.style.color = t2, function(e5) {
            let [t3, n3, r2, i2 = 1] = e5.replace(/rgba?\((.+)\)/, (e6, t4) => t4).split(/,\s*/);
            return { r: t3, g: n3, b: r2, a: i2 };
          }(getComputedStyle(n2).color)) : { r: 0, g: 0, b: 0, a: 1 };
        }(this.shadowRoot, e3) };
      }
      connectedCallback(e3) {
        this.innerHTML ? this.load(e3) : setTimeout(() => this.load(e3));
      }
      disconnectedCallback() {
        this.cleanup();
      }
      cleanup() {
        Fe.clear();
        for (let e3 of this.animations)
          e3.cancel();
        this.animations = [];
      }
      update(e3) {
        this.cleanup(), e3 || (e3 = N(this._innerHTML)), this._innerHTML !== e3 && (this._innerHTML = e3), this.grid_size || (this.grid_size = this.get_grid());
        const { x: t2, y: n2, z: r2 } = this.grid_size, i2 = this.get_use();
        let s2 = "", l2 = "";
        this.compiled && (s2 = this.compiled.content, l2 = this.compiled.styles.all);
        const o2 = this.generate(Ee(i2 + e3, this.extra));
        let a2 = o2.grid || this.get_grid(), { x: u2, y: c2, z: h2 } = a2, p2 = !this.shadowRoot.innerHTML || this.shadowRoot.querySelector("css-doodle") || t2 !== u2 || n2 !== c2 || r2 !== h2 || JSON.stringify(s2) !== JSON.stringify(o2.content);
        if (Object.assign(this.grid_size, a2), p2)
          return o2.grid ? this.build_grid(o2, a2) : this.build_grid(this.generate(Ee(i2 + e3, this.extra)), a2);
        let f2 = this.replace(o2);
        o2.props.has_animation && (this.set_style(l2.replace(/animation/g, "x")), this.reflow()), this.set_style(f2(Xn(this.grid_size) + o2.styles.all));
      }
      get grid() {
        return Object.assign({}, this.grid_size);
      }
      set grid(e3) {
        this.attr("grid", e3), this.connectedCallback(true);
      }
      get seed() {
        return this._seed_value;
      }
      set seed(e3) {
        this.attr("seed", e3), this.connectedCallback(true);
      }
      get use() {
        return this.attr("use");
      }
      set use(e3) {
        this.attr("use", e3), this.connectedCallback(true);
      }
      get_max_grid() {
        return this.hasAttribute("experimental") ? 256 : 64;
      }
      get_grid() {
        return Te(this.attr("grid"), this.get_max_grid());
      }
      get_use() {
        let e3 = String(this.attr("use") || "").trim();
        return /^var\(/.test(e3) && (e3 = `@use:${e3};`), e3;
      }
      attr(e3, t2) {
        let n2 = arguments.length;
        return 1 === n2 ? this.getAttribute(e3) : 2 === n2 ? (this.setAttribute(e3, t2), t2) : void 0;
      }
      generate(e3) {
        let t2 = this.get_grid(), n2 = this.attr("seed") || this.attr("data-seed");
        x(n2) && (n2 = Date.now());
        let r2 = this.compiled = Tn(e3, t2, n2, this.get_max_grid());
        return this._seed_value = r2.seed, this._seed_random = r2.random, r2;
      }
      doodle_to_image(e3, t2, n2) {
        "function" == typeof t2 && (n2 = t2, t2 = null);
        let r2 = Ee(e3 = ":doodle{width:100%;height:100%}" + e3, this.extra), i2 = Te(""), s2 = Tn(r2, i2, this._seed_value, this.get_max_grid(), this._seed_random), l2 = s2.grid ? s2.grid : i2, o2 = "";
        if (t2 && t2.arg) {
          let e4 = Te(t2.arg, 1 / 0);
          e4.x && e4.y && (t2.width = e4.x + "px", t2.height = e4.y + "px", o2 = `viewBox="0 0 ${e4.x} ${e4.y}"`);
        }
        let a2 = this.replace(s2), u2 = Yn(l2, s2.content);
        a2(`
<svg ${t2 && t2.width && t2.height ? `width="${t2.width}" height="${t2.height}"` : ""} ${Pe} preserveAspectRatio="none" ${o2}><foreignObject width="100%" height="100%"><div class="host" width="100%" height="100%" ${Oe}><style>${Xn(l2)} ${s2.styles.all}</style>${u2}</div></foreignObject></svg>`).then((e4) => {
          let t3 = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(e4)))}`;
          A() && j(t3), n2(t3);
        });
      }
      pattern_to_image({ code: e3, cell: t2, id: n2 }, r2) {
        let i2 = Bn(e3, this.extra);
        this.shader_to_image({ shader: i2, cell: t2, id: n2 }, r2);
      }
      pause() {
        this.setAttribute("cssd-paused", true);
        for (let e3 of this.animations)
          e3.pause();
      }
      resume() {
        this.removeAttribute("cssd-paused");
        for (let e3 of this.animations)
          e3.resume();
      }
      shader_to_image({ shader: e3, cell: t2, id: n2 }, i2) {
        const s2 = this.doodle.getElementById(t2);
        if (!s2)
          return false;
        let { width: l2, height: o2 } = s2.getBoundingClientRect(), a2 = devicePixelRatio || 1, u2 = this.seed, c2 = "string" == typeof e3 ? function(e4) {
          let t3, n3, i3 = r(Ce(p(e4, { preserveLineBreak: true, ignoreInlineComment: true }))), s3 = [], l3 = [], o3 = { textures: [] };
          for (; i3.next(); ) {
            let { curr: e5, next: r2 } = i3.get();
            if (e5.isSymbol("{")) {
              if (s3.length)
                l3.push(e5);
              else {
                let n4 = Me(l3);
                Re(n4) ? (t3 = n4, l3 = []) : l3.push(e5);
              }
              s3.push("{");
            } else if (e5.isSymbol("}"))
              if (s3.pop(), !s3.length && t3) {
                let e6 = Me(l3);
                t3 && e6.length && (t3.startsWith("texture") ? o3.textures.push({ name: t3, value: e6 }) : o3[t3] = e6, l3 = []), t3 = null;
              } else
                l3.push(e5);
            else
              $(n3) || n3 == e5.pos[1] || (l3.push(ze()), n3 = null), t3 && t3.startsWith("texture") || e5.isWord() && e5.value.startsWith("#") && (l3.push(ze()), n3 = r2.pos[1]), l3.push(e5);
          }
          return $(o3.fragment) && (o3.fragment = Me(l3), o3.textures = o3.textures || []), o3;
        }(e3) : e3;
        c2.width = l2, c2.height = o2;
        let h2 = c2.textures, f2 = [];
        const d2 = (e4) => {
          s2.style.setProperty(n2, `url(${e4})`);
        }, m2 = (e4) => {
          "function" == typeof e4 ? this.animations.push(function(e5) {
            let t3, n3 = 0, r2 = 0, i3 = 0, s3 = false;
            function l3(s4) {
              n3 || (n3 = s4), e5(n3);
              let o3 = s4 - r2;
              o3 < Fn && (o3 = Fn), o3 > 1e3 && (o3 = i3 || 1e3), r2 && (n3 += o3), i3 = o3, r2 = s4, t3 = requestAnimationFrame(l3);
            }
            return t3 = requestAnimationFrame(l3), { resume() {
              t3 && s3 && (s3 = false, t3 = requestAnimationFrame(l3));
            }, pause() {
              t3 && (cancelAnimationFrame(t3), s3 = true);
            }, cancel() {
              t3 && (s3 = false, cancelAnimationFrame(t3), t3 = null);
            } };
          }((t3) => {
            d2(e4(t3, l2, o2, f2));
          })) : d2(e4);
        }, g2 = (e4, t3) => {
          Promise.all(e4.map(({ name: e5, value: t4 }) => new Promise((n3) => {
            this.doodle_to_image(t4, { width: l2, height: o2 }, (t5) => {
              let r2 = new Image();
              r2.width = l2 * a2, r2.height = l2 * a2, r2.onload = () => n3({ name: e5, value: r2 }), r2.src = t5;
            });
          }))).then(t3);
        };
        s2.observer || (s2.observer = new ResizeObserver(() => {
          let e4 = s2.getBoundingClientRect();
          l2 = e4.width, o2 = e4.height, g2(h2, (e5) => f2 = e5);
        }), s2.observer.observe(s2)), h2.length ? g2(h2, (e4) => {
          c2.textures = f2 = e4, c2.width = l2, c2.height = o2, Cn(c2, u2).then(m2).then(i2);
        }) : Cn(c2, u2).then(m2).then(i2);
      }
      load(e3) {
        this.cleanup();
        let t2 = Ee(this.get_use() + N(this.innerHTML), this.extra), n2 = this.generate(t2);
        e3 || this.hasAttribute("click-to-update") && this.addEventListener("click", (e4) => this.update()), this.grid_size = n2.grid ? n2.grid : this.get_grid(), this.build_grid(n2, this.grid_size), this._innerHTML = this.innerHTML, this.innerHTML = "";
      }
      replace({ doodles: e3, shaders: t2, pattern: n2 }) {
        let r2 = Object.keys(e3), i2 = Object.keys(t2), s2 = Object.keys(n2), l2 = r2.length + i2.length + s2.length;
        return (o2) => {
          if (!l2)
            return Promise.resolve(o2);
          let a2 = [].concat(r2.map((t3) => o2.includes(t3) ? new Promise((n3) => {
            let { arg: r3, doodle: i3 } = e3[t3];
            this.doodle_to_image(i3, { arg: r3 }, (e4) => n3({ id: t3, value: e4 }));
          }) : Promise.resolve("")), i2.map((e4) => o2.includes(e4) ? new Promise((n3) => {
            this.shader_to_image(t2[e4], (t3) => n3({ id: e4, value: t3 }));
          }) : Promise.resolve("")), s2.map((e4) => o2.includes(e4) ? new Promise((t3) => {
            this.pattern_to_image(n2[e4], (n3) => t3({ id: e4, value: n3 }));
          }) : Promise.resolve("")));
          return Promise.all(a2).then((e4) => {
            for (let { id: t3, value: n3 } of e4) {
              let e5 = `url(${n3})`;
              /^shader|^pattern/.test(t3) && (e5 = `var(--${t3})`), o2 = o2.replaceAll("${" + t3 + "}", e5);
            }
            return o2;
          });
        };
      }
      reflow() {
        this.shadowRoot.querySelector("grid").offsetWidth;
      }
      build_grid(e3, t2) {
        const { has_transition: n2, has_animation: r2 } = e3.props;
        let i2 = n2 || r2;
        const { uniforms: s2, content: l2, styles: o2 } = e3;
        this.doodle.innerHTML = `
<style>${Xn(t2) + o2.main}</style>${Yn(t2, l2)}`, i2 && this.reflow();
        let a2 = this.replace(e3);
        this.set_style(a2(Xn(t2) + o2.all)), s2.time && this.register_utime(), s2.mousex || s2.mousey ? this.register_umouse(s2) : this.remove_umouse(), s2.width || s2.height ? this.register_usize(s2) : this.remove_usize();
      }
      register_umouse(e3) {
        if (!this.umouse_fn) {
          this.umouse_fn = (t3) => {
            let n2 = t3.detail || t3;
            e3.mousex && this.style.setProperty("--" + ct, n2.offsetX), e3.mousey && this.style.setProperty("--" + ht, n2.offsetY);
          }, this.addEventListener("pointermove", this.umouse_fn);
          let t2 = new CustomEvent("pointermove", { detail: { offsetX: 0, offsetY: 0 } });
          this.dispatchEvent(t2);
        }
      }
      remove_umouse() {
        this.umouse_fn && (this.style.removeProperty("--" + ct), this.style.removeProperty("--" + ht), this.removeEventListener("pointermove", this.umouse_fn), this.umouse_fn = null);
      }
      register_usize(e3) {
        this.usize_observer || (this.usize_observer = new ResizeObserver(() => {
          let t2 = this.getBoundingClientRect();
          e3.width && this.style.setProperty("--" + pt, t2.width), e3.height && this.style.setProperty("--" + ft, t2.height);
        }), this.usize_observer.observe(this));
      }
      remove_usize() {
        this.usize_observer && (this.style.removeProperty("--" + pt), this.style.removeProperty("--" + ft), this.usize_observer.unobserve(this), this.usize_observer = null);
      }
      register_utime() {
        if (!this.is_utime_set) {
          try {
            CSS.registerProperty({ name: "--" + ut.name, syntax: "<number>", initialValue: 0, inherits: true });
          } catch (e3) {
          }
          this.is_utime_set = true;
        }
      }
      export({ scale: e3, name: t2, download: n2, detail: r2 } = {}) {
        return new Promise((i2, s2) => {
          let l2 = Un(this), o2 = this.doodle.innerHTML, { width: a2, height: u2 } = this.getBoundingClientRect(), c2 = a2 * (e3 = parseInt(e3) || 1), h2 = u2 * e3, p2 = `
<svg ${Pe} preserveAspectRatio="none"
 viewBox="0 0 ${a2} ${u2}"
 ${A() ? "" : `width="${c2}px" height="${h2}px"`}><foreignObject width="100%" height="100%"><div class="host" ${Oe} style="width:${a2}px;height:${u2}px"><style>.host{${f2 = l2, f2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;")}}</style>${o2}</div></foreignObject></svg>`;
          var f2;
          n2 || r2 ? function(e4, t3, n3, r3) {
            return new Promise((i3, s3) => {
              let l3 = `data:image/svg+xml;utf8,${encodeURIComponent(e4)}`;
              function o3() {
                let e5 = new Image();
                e5.crossOrigin = "anonymous", e5.src = l3, e5.onload = () => {
                  let o4 = document.createElement("canvas"), a3 = o4.getContext("2d"), u3 = devicePixelRatio || 1;
                  1 != r3 && (u3 = 1), o4.width = t3 * u3, o4.height = n3 * u3, a3.drawImage(e5, 0, 0, o4.width, o4.height);
                  try {
                    o4.toBlob((e6) => {
                      i3({ blob: e6, source: l3, url: URL.createObjectURL(e6) });
                    });
                  } catch (e6) {
                    s3(e6);
                  }
                };
              }
              A() ? j(l3, o3, 200) : o3();
            });
          }(p2, c2, h2, e3).then(({ source: e4, url: r3, blob: s3 }) => {
            if (i2({ width: c2, height: h2, svg: p2, blob: s3, source: e4 }), n2) {
              let e5 = document.createElement("a");
              e5.download = function(e6) {
                return (x(e6) ? Date.now() : String(e6).replace(/\/.png$/g, "")) + ".png";
              }(t2), e5.href = r3, e5.click();
            }
          }).catch((e4) => {
            s2(e4);
          }) : i2({ width: c2, height: h2, svg: p2 });
        });
      }
      set_style(e3) {
        if (e3 instanceof Promise)
          e3.then((e4) => {
            this.set_style(e4);
          });
        else {
          const t2 = this.shadowRoot.querySelector("style");
          let n2 = e3.replace(/\n\s+/g, " ");
          t2 && (t2.styleSheet ? t2.styleSheet.cssText = n2 : t2.innerHTML = n2);
        }
      }
    }
    customElements.get("css-doodle") || customElements.define("css-doodle", e2);
  }
  function Xn(e2) {
    let { x: t2, y: n2 } = e2 || {};
    return `
 *,*::after,*::before{box-sizing:border-box;}:host,.host{display:block;visibility:visible;width:auto;height:auto;contain:content;box-sizing:border-box;--${ut.name}:0
}:host([hidden]),[hidden]{display:none
}:host([cssd-paused]),
:host([cssd-paused]) *{animation-play-state:paused !important
} grid, cell{display:grid;position:relative;} grid{gap:inherit;grid-template:repeat(${n2},1fr)/repeat(${t2},1fr)
} cell{place-items:center
} svg{position:absolute;} grid, svg{width:100%;height:100%
}`;
  }
  function qn(e2) {
    return x(e2) ? "" : e2;
  }
  function Hn(e2, t2, n2, r2, i2 = "") {
    let s2 = k(e2, t2, n2);
    return `<cell id="${s2}">${qn(r2["#" + s2])}${qn(i2)}</cell>`;
  }
  function Yn(e2, t2) {
    let { x: n2, y: r2, z: i2 } = e2 || {}, s2 = "";
    if (1 == i2)
      for (let e3 = 1; e3 <= r2; ++e3)
        for (let r3 = 1; r3 <= n2; ++r3)
          s2 += Hn(r3, e3, 1, t2);
    else {
      let e3 = "";
      for (let n3 = i2; n3 >= 1; n3--) {
        e3 = Hn(1, 1, n3, t2, e3);
      }
      s2 = e3;
    }
    return `<grid>${s2}</grid>`;
  }
}();
/*! Bundled license information:

css-doodle/css-doodle.min.js:
  (*! css-doodle@0.38.3 *)
*/
//# sourceMappingURL=css-doodle.js.map
